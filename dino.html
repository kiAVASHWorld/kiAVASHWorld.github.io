<html dir="ltr" lang="en" class="offline"><head>
    <meta charset="utf-8">
    <meta name="color-scheme" content="light dark">
    <meta name="theme-color" content="#fff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,
                                   maximum-scale=1.0, user-scalable=no">
    <title>chrome://dino/</title>
    <style>/* Copyright 2017 The Chromium Authors
   * Use of this source code is governed by a BSD-style license that can be
   * found in the LICENSE file. */
  
  a {
    color: var(--link-color);
  }
  
  body {
    --background-color: #fff;
    --error-code-color: var(--google-gray-700);
    --google-blue-100: rgb(210, 227, 252);
    --google-blue-300: rgb(138, 180, 248);
    --google-blue-600: rgb(26, 115, 232);
    --google-blue-700: rgb(25, 103, 210);
    --google-gray-100: rgb(241, 243, 244);
    --google-gray-300: rgb(218, 220, 224);
    --google-gray-500: rgb(154, 160, 166);
    --google-gray-50: rgb(248, 249, 250);
    --google-gray-600: rgb(128, 134, 139);
    --google-gray-700: rgb(95, 99, 104);
    --google-gray-800: rgb(60, 64, 67);
    --google-gray-900: rgb(32, 33, 36);
    --heading-color: var(--google-gray-900);
    --link-color: rgb(88, 88, 88);
    --popup-container-background-color: rgba(0,0,0,.65);
    --primary-button-fill-color-active: var(--google-blue-700);
    --primary-button-fill-color: var(--google-blue-600);
    --primary-button-text-color: #fff;
    --quiet-background-color: rgb(247, 247, 247);
    --secondary-button-border-color: var(--google-gray-500);
    --secondary-button-fill-color: #fff;
    --secondary-button-hover-border-color: var(--google-gray-600);
    --secondary-button-hover-fill-color: var(--google-gray-50);
    --secondary-button-text-color: var(--google-gray-700);
    --small-link-color: var(--google-gray-700);
    --text-color: var(--google-gray-700);
    background: var(--background-color);
    color: var(--text-color);
    word-wrap: break-word;
  }
  
  .nav-wrapper .secondary-button {
    background: var(--secondary-button-fill-color);
    border: 1px solid var(--secondary-button-border-color);
    color: var(--secondary-button-text-color);
    float: none;
    margin: 0;
    padding: 8px 16px;
  }
  
  .hidden {
    display: none;
  }
  
  html {
    -webkit-text-size-adjust: 100%;
    font-size: 125%;
  }
  
  .icon {
    background-repeat: no-repeat;
    background-size: 100%;
  }
  
  @media (prefers-color-scheme: dark) {
    body {
      --background-color: var(--google-gray-900);
      --error-code-color: var(--google-gray-500);
      --heading-color: var(--google-gray-500);
      --link-color: var(--google-blue-300);
      --primary-button-fill-color-active: rgb(129, 162, 208);
      --primary-button-fill-color: var(--google-blue-300);
      --primary-button-text-color: var(--google-gray-900);
      --quiet-background-color: var(--background-color);
      --secondary-button-border-color: var(--google-gray-700);
      --secondary-button-fill-color: var(--google-gray-900);
      --secondary-button-hover-fill-color: rgb(48, 51, 57);
      --secondary-button-text-color: var(--google-blue-300);
      --small-link-color: var(--google-blue-300);
      --text-color: var(--google-gray-500);
    }
  }
  </style>
    <style>/* Copyright 2014 The Chromium Authors
     Use of this source code is governed by a BSD-style license that can be
     found in the LICENSE file. */
  
  button {
    border: 0;
    border-radius: 4px;
    box-sizing: border-box;
    color: var(--primary-button-text-color);
    cursor: pointer;
    float: right;
    font-size: .875em;
    margin: 0;
    padding: 8px 16px;
    transition: box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1);
    user-select: none;
  }
  
  [dir='rtl'] button {
    float: left;
  }
  
  .bad-clock button,
  .captive-portal button,
  .https-only button,
  .insecure-form button,
  .lookalike-url button,
  .main-frame-blocked button,
  .neterror button,
  .pdf button,
  .ssl button,
  .enterprise-block button,
  .enterprise-warn button,
  .safe-browsing-billing button {
    background: var(--primary-button-fill-color);
  }
  
  button:active {
    background: var(--primary-button-fill-color-active);
    outline: 0;
  }
  
  #debugging {
    display: inline;
    overflow: auto;
  }
  
  .debugging-content {
    line-height: 1em;
    margin-bottom: 0;
    margin-top: 1em;
  }
  
  .debugging-content-fixed-width {
    display: block;
    font-family: monospace;
    font-size: 1.2em;
    margin-top: 0.5em;
  }
  
  .debugging-title {
    font-weight: bold;
  }
  
  #details {
    margin: 0 0 50px;
  }
  
  #details p:not(:first-of-type) {
    margin-top: 20px;
  }
  
  .secondary-button:active {
    border-color: white;
    box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3),
        0 2px 6px 2px rgba(60, 64, 67, .15);
  }
  
  .secondary-button:hover {
    background: var(--secondary-button-hover-fill-color);
    border-color: var(--secondary-button-hover-border-color);
    text-decoration: none;
  }
  
  .error-code {
    color: var(--error-code-color);
    font-size: .8em;
    margin-top: 12px;
    text-transform: uppercase;
  }
  
  #error-debugging-info {
    font-size: 0.8em;
  }
  
  h1 {
    color: var(--heading-color);
    font-size: 1.6em;
    font-weight: normal;
    line-height: 1.25em;
    margin-bottom: 16px;
  }
  
  h2 {
    font-size: 1.2em;
    font-weight: normal;
  }
  
  .icon {
    height: 72px;
    margin: 0 0 40px;
    width: 72px;
  }
  
  input[type=checkbox] {
    opacity: 0;
  }
  
  input[type=checkbox]:focus ~ .checkbox::after {
    outline: -webkit-focus-ring-color auto 5px;
  }
  
  .interstitial-wrapper {
    box-sizing: border-box;
    font-size: 1em;
    line-height: 1.6em;
    margin: 14vh auto 0;
    max-width: 600px;
    width: 100%;
  }
  
  #main-message > p {
    display: inline;
  }
  
  #extended-reporting-opt-in {
    font-size: .875em;
    margin-top: 32px;
  }
  
  #extended-reporting-opt-in label {
    display: grid;
    grid-template-columns: 1.8em 1fr;
    position: relative;
  }
  
  #enhanced-protection-message {
    border-radius: 4px;
    font-size: 1em;
    margin-top: 32px;
    padding: 10px 5px;
  }
  
  #enhanced-protection-message label {
    display: grid;
    grid-template-columns: 2.5em 1fr;
    position: relative;
  }
  
  #enhanced-protection-message div {
    margin: 0.5em;
  }
  
  #enhanced-protection-message .icon {
    height: 1.5em;
    vertical-align: middle;
    width: 1.5em;
  }
  
  .nav-wrapper {
    margin-top: 51px;
  }
  
  .nav-wrapper::after {
    clear: both;
    content: '';
    display: table;
    width: 100%;
  }
  
  .small-link {
    color: var(--small-link-color);
    font-size: .875em;
  }
  
  .checkboxes {
    flex: 0 0 24px;
  }
  
  .checkbox {
    --padding: .9em;
    background: transparent;
    display: block;
    height: 1em;
    left: -1em;
    padding-inline-start: var(--padding);
    position: absolute;
    right: 0;
    top: -.5em;
    width: 1em;
  }
  
  .checkbox::after {
    border: 1px solid white;
    border-radius: 2px;
    content: '';
    height: 1em;
    left: var(--padding);
    position: absolute;
    top: var(--padding);
    width: 1em;
  }
  
  .checkbox::before {
    background: transparent;
    border: 2px solid white;
    border-inline-end-width: 0;
    border-top-width: 0;
    content: '';
    height: .2em;
    left: calc(.3em + var(--padding));
    opacity: 0;
    position: absolute;
    top: calc(.3em  + var(--padding));
    transform: rotate(-45deg);
    width: .5em;
  }
  
  input[type=checkbox]:checked ~ .checkbox::before {
    opacity: 1;
  }
  
  #recurrent-error-message {
    background: #ededed;
    border-radius: 4px;
    margin-bottom: 16px;
    margin-top: 12px;
    padding: 12px 16px;
  }
  
  .showing-recurrent-error-message #extended-reporting-opt-in {
    margin-top: 16px;
  }
  
  .showing-recurrent-error-message #enhanced-protection-message {
    margin-top: 16px;
  }
  
  @media (max-width: 700px) {
    .interstitial-wrapper {
      padding: 0 10%;
    }
  
    #error-debugging-info {
      overflow: auto;
    }
  }
  
  @media (max-width: 420px) {
    button,
    [dir='rtl'] button,
    .small-link {
      float: none;
      font-size: .825em;
      font-weight: 500;
      margin: 0;
      width: 100%;
    }
  
    button {
      padding: 16px 24px;
    }
  
    #details {
      margin: 20px 0 20px 0;
    }
  
    #details p:not(:first-of-type) {
      margin-top: 10px;
    }
  
    .secondary-button:not(.hidden) {
      display: block;
      margin-top: 20px;
      text-align: center;
      width: 100%;
    }
  
    .interstitial-wrapper {
      padding: 0 5%;
    }
  
    #extended-reporting-opt-in {
      margin-top: 24px;
    }
  
    #enhanced-protection-message {
      margin-top: 24px;
    }
  
    .nav-wrapper {
      margin-top: 30px;
    }
  }
  
  /**
   * Mobile specific styling.
   * Navigation buttons are anchored to the bottom of the screen.
   * Details message replaces the top content in its own scrollable area.
   */
  
  @media (max-width: 420px) {
    .nav-wrapper .secondary-button {
      border: 0;
      margin: 16px 0 0;
      margin-inline-end: 0;
      padding-bottom: 16px;
      padding-top: 16px;
    }
  }
  
  /* Fixed nav. */
  @media (min-width: 240px) and (max-width: 420px) and
         (min-height: 401px),
         (min-width: 421px) and (min-height: 240px) and
         (max-height: 560px) {
    body .nav-wrapper {
      background: var(--background-color);
      bottom: 0;
      box-shadow: 0 -12px 24px var(--background-color);
      left: 0;
      margin: 0 auto;
      max-width: 736px;
      padding-inline-end: 24px;
      padding-inline-start: 24px;
      position: fixed;
      right: 0;
      width: 100%;
      z-index: 2;
    }
  
    .interstitial-wrapper {
      max-width: 736px;
    }
  
    #details,
    #main-content {
      padding-bottom: 40px;
    }
  
    #details {
      padding-top: 5.5vh;
    }
  
    button.small-link {
      color: var(--google-blue-600);
    }
  }
  
  @media (max-width: 420px) and (orientation: portrait),
         (max-height: 560px) {
    body {
      margin: 0 auto;
    }
  
    button,
    [dir='rtl'] button,
    button.small-link,
    .nav-wrapper .secondary-button {
      font-family: Roboto-Regular,Helvetica;
      font-size: .933em;
      margin: 6px 0;
      transform: translatez(0);
    }
  
    .nav-wrapper {
      box-sizing: border-box;
      padding-bottom: 8px;
      width: 100%;
    }
  
    #details {
      box-sizing: border-box;
      height: auto;
      margin: 0;
      opacity: 1;
      transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);
    }
  
    #details.hidden,
    #main-content.hidden {
      height: 0;
      opacity: 0;
      overflow: hidden;
      padding-bottom: 0;
      transition: none;
    }
  
    h1 {
      font-size: 1.5em;
      margin-bottom: 8px;
    }
  
    .icon {
      margin-bottom: 5.69vh;
    }
  
    .interstitial-wrapper {
      box-sizing: border-box;
      margin: 7vh auto 12px;
      padding: 0 24px;
      position: relative;
    }
  
    .interstitial-wrapper p {
      font-size: .95em;
      line-height: 1.61em;
      margin-top: 8px;
    }
  
    #main-content {
      margin: 0;
      transition: opacity 100ms cubic-bezier(0.4, 0, 0.2, 1);
    }
  
    .small-link {
      border: 0;
    }
  
    .suggested-left > #control-buttons,
    .suggested-right > #control-buttons {
      float: none;
      margin: 0;
    }
  }
  
  @media (min-width: 421px) and (min-height: 500px) and (max-height: 560px) {
    .interstitial-wrapper {
      margin-top: 10vh;
    }
  }
  
  @media (min-height: 400px) and (orientation:portrait) {
    .interstitial-wrapper {
      margin-bottom: 145px;
    }
  }
  
  @media (min-height: 299px) {
    .nav-wrapper {
      padding-bottom: 16px;
    }
  }
  
  @media (max-height: 560px) and (min-height: 240px) and (orientation:landscape) {
    .extended-reporting-has-checkbox #details {
      padding-bottom: 80px;
    }
  }
  
  @media (min-height: 500px) and (max-height: 650px) and (max-width: 414px) and
         (orientation: portrait) {
    .interstitial-wrapper {
      margin-top: 7vh;
    }
  }
  
  @media (min-height: 650px) and (max-width: 414px) and (orientation: portrait) {
    .interstitial-wrapper {
      margin-top: 10vh;
    }
  }
  
  /* Small mobile screens. No fixed nav. */
  @media (max-height: 400px) and (orientation: portrait),
         (max-height: 239px) and (orientation: landscape),
         (max-width: 419px) and (max-height: 399px) {
    .interstitial-wrapper {
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
    }
  
    #details {
      flex: 1 1 auto;
      order: 0;
    }
  
    #main-content {
      flex: 1 1 auto;
      order: 0;
    }
  
    .nav-wrapper {
      flex: 0 1 auto;
      margin-top: 8px;
      order: 1;
      padding-inline-end: 0;
      padding-inline-start: 0;
      position: relative;
      width: 100%;
    }
  
    button,
    .nav-wrapper .secondary-button {
      padding: 16px 24px;
    }
  
    button.small-link {
      color: var(--google-blue-600);
    }
  }
  
  @media (max-width: 239px) and (orientation: portrait) {
    .nav-wrapper {
      padding-inline-end: 0;
      padding-inline-start: 0;
    }
  }
  </style>
    <style>/* Copyright 2013 The Chromium Authors
   * Use of this source code is governed by a BSD-style license that can be
   * found in the LICENSE file. */
  
  /* Don't use the main frame div when the error is in a subframe. */
  html[subframe] #main-frame-error {
    display: none;
  }
  
  /* Don't use the subframe error div when the error is in a main frame. */
  html:not([subframe]) #sub-frame-error {
    display: none;
  }
  
  h1 {
    margin-top: 0;
    word-wrap: break-word;
  }
  
  h1 span {
    font-weight: 500;
  }
  
  a {
    text-decoration: none;
  }
  
  .icon {
    -webkit-user-select: none;
    display: inline-block;
  }
  
  .icon-generic {
    /* Can't access chrome://theme/IDR_ERROR_NETWORK_GENERIC from an untrusted
     * renderer process, so embed the resource manually. */
    content: -webkit-image-set(
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAENJREFUeF7tzbEJACEQRNGBLeAasBCza2lLEGx0CxFGG9hBMDDxRy/72O9FMnIFapGylsu1fgoBdkXfUHLrQgdfrlJN1BdYBjQQm3UAAAAASUVORK5CYII=) 1x,
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQAQMAAADdiHD7AAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAFJJREFUeF7t0cENgDAMQ9FwYgxG6WjpaIzCCAxQxVggFuDiCvlLOeRdHR9yzjncHVoq3npu+wQUrUuJHylSTmBaespJyJQoObUeyxDQb3bEm5Au81c0pSCD8HYAAAAASUVORK5CYII=) 2x);
  }
  
  .icon-offline {
    content: -webkit-image-set(
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==) 1x,
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQBAMAAAAVaP+LAAAAGFBMVEUAAABTU1NNTU1TU1NPT09SUlJSUlJTU1O8B7DEAAAAB3RSTlMAoArVKvVgBuEdKgAAAJ1JREFUeF7t1TEOwyAMQNG0Q6/UE+RMXD9d/tC6womIFSL9P+MnAYOXeTIzMzMzMzMzaz8J9Ri6HoITmuHXhISE8nEh9yxDh55aCEUoTGbbQwjqHwIkRAEiIaG0+0AA9VBMaE89Rogeoww936MQrWdBr4GN/z0IAdQ6nQ/FIpRXDwHcA+JIJcQowQAlFUA0MfQpXLlVQfkzR4igS6ENjknm/wiaGhsAAAAASUVORK5CYII=) 2x);
    position: relative;
  }
  
  .icon-disabled {
    content: -webkit-image-set(
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAABICAMAAAAZF4G5AAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAASZJREFUeAHd11Fq7jAMRGGf/W/6PoWB67YMqv5DybwG/CFjRuR8JBw3+ByiRjgV9W/TJ31P0tBfC6+cj1haUFXKHmVJo5wP98WwQ0ZCbfUc6LQ6VuUBz31ikADkLMkDrfUC4rR6QGW+gF6rx7NaHWCj1Y/W6lf4L7utvgBSt3rBFSS/XBMPUILcJINHCBWYUfpWn4NBi1ZfudIc3rf6/NGEvEA+AsYTJozmXemjXeLZAov+mnkN2HfzXpMSVQDnGw++57qNJ4D1xitA2sJ+VAWMygSEaYf2mYPTjZfk2K8wmP7HLIH5Mg4/pP+PEcDzUvDMvYbs/2NWwPO5vBdMZE4EE5UTQLiBFDaUlTDPBRoJ9HdAYIkIo06og3BNXtCzy7zA1aXk5x+tJARq63eAygAAAABJRU5ErkJggg==) 1x,
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAACQAQMAAAArwfVjAAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAAYdJREFUeF7F1EFqwzAUBNARAmVj0FZe5QoBH6BX+dn4GlY2PYNzGx/A0CvkCIJuvIraKJKbgBvzf2g62weDGD7CYggpfFReis4J0ey9EGFIiEQQojFSlA9kSIiqd0KkFjKsewgRbStEN19mxUPTtmW9HQ/h6tyqNQ8NlSMZdzyE6qkoE0trVYGFm0n1WYeBhduzwbwBC7voS+vIxfeMjeaiLxsMMtQNwMPtuew+DjzcTHk8YMfDknEcIUOtf2lVfgVH3K4Xv5PRYAXRVMtItIJ3rfaCIVn9DsTH2NxisAVRex2Hh3hX+/mRUR08bAwPEYsI51ZxWH4Q0SpicQRXeyEaIug48FEdegARfMz/tADVsRciwTAxW308ehmC2gLraC+YCbV3QoTZexa+zegAEW5PhhgYfmbvJgcRqngGByOSXdFJcLk2JeDPEN0kxe1JhIt5FiFA+w+ItMELsUyPF2IaJ4aILqb4FbxPwhImwj6JauKgDUCYaxmYIsd4KXdMjIC9ItB5Bn4BNRwsG0XM2nwAAAAASUVORK5CYII=) 2x);
    width: 112px;
  }
  
  .hidden {
    display: none;
  }
  
  #suggestions-list a {
    color: var(--google-blue-600);
  }
  
  #suggestions-list p {
    margin-block-end: 0;
  }
  
  #suggestions-list ul {
    margin-top: 0;
  }
  
  .single-suggestion {
    list-style-type: none;
    padding-inline-start: 0;
  }
  
  #error-information-button {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBkPSJNMCAwaDI0djI0SDB6Ii8+PHBhdGggZD0iTTExIDE4aDJ2LTJoLTJ2MnptMS0xNkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6bTAtMTRjLTIuMjEgMC00IDEuNzktNCA0aDJjMC0xLjEuOS0yIDItMnMyIC45IDIgMmMwIDItMyAxLjc1LTMgNWgyYzAtMi4yNSAzLTIuNSAzLTUgMC0yLjIxLTEuNzktNC00LTR6Ii8+PC9zdmc+);
    height: 24px;
    vertical-align: -.15em;
    width: 24px;
  }
  
  .use-popup-container#error-information-popup-container
    #error-information-popup {
    align-items: center;
    background-color: var(--popup-container-background-color);
    display: flex;
    height: 100%;
    left: 0;
    position: fixed;
    top: 0;
    width: 100%;
    z-index: 100;
  }
  
  .use-popup-container#error-information-popup-container
    #error-information-popup-content > p {
    margin-bottom: 11px;
    margin-inline-start: 20px;
  }
  
  .use-popup-container#error-information-popup-container #suggestions-list ul {
    margin-inline-start: 15px;
  }
  
  .use-popup-container#error-information-popup-container
    #error-information-popup-box {
    background-color: var(--background-color);
    left: 5%;
    padding-bottom: 15px;
    padding-top: 15px;
    position: fixed;
    width: 90%;
    z-index: 101;
  }
  
  .use-popup-container#error-information-popup-container div.error-code {
    margin-inline-start: 20px;
  }
  
  .use-popup-container#error-information-popup-container #suggestions-list p {
    margin-inline-start: 20px;
  }
  
  :not(.use-popup-container)#error-information-popup-container
    #error-information-popup-close {
    display: none;
  }
  
  #error-information-popup-close {
    margin-bottom: 0;
    margin-inline-end: 35px;
    margin-top: 15px;
    text-align: end;
  }
  
  .link-button {
    color: rgb(66, 133, 244);
    display: inline-block;
    font-weight: bold;
    text-transform: uppercase;
  }
  
  #sub-frame-error-details {
  
    color: #8F8F8F;
  
    /* Not done on mobile for performance reasons. */
    text-shadow: 0 1px 0 rgba(255,255,255,0.3);
  
  }
  
  [jscontent=hostName],
  [jscontent=failedUrl] {
    overflow-wrap: break-word;
  }
  
  .secondary-button {
    background: #d9d9d9;
    color: #696969;
    margin-inline-end: 16px;
  }
  
  .snackbar {
    background: #323232;
    border-radius: 2px;
    bottom: 24px;
    box-sizing: border-box;
    color: #fff;
    font-size: .87em;
    left: 24px;
    max-width: 568px;
    min-width: 288px;
    opacity: 0;
    padding: 16px 24px 12px;
    position: fixed;
    transform: translateY(90px);
    will-change: opacity, transform;
    z-index: 999;
  }
  
  .snackbar-show {
    -webkit-animation:
      show-snackbar 250ms cubic-bezier(0, 0, 0.2, 1) forwards,
      hide-snackbar 250ms cubic-bezier(0.4, 0, 1, 1) forwards 5s;
  }
  
  @-webkit-keyframes show-snackbar {
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @-webkit-keyframes hide-snackbar {
    0% {
      opacity: 1;
      transform: translateY(0);
    }
    100% {
      opacity: 0;
      transform: translateY(90px);
    }
  }
  
  .suggestions {
    margin-top: 18px;
  }
  
  .suggestion-header {
    font-weight: bold;
    margin-bottom: 4px;
  }
  
  .suggestion-body {
    color: #777;
  }
  
  /* Decrease padding at low sizes. */
  @media (max-width: 640px), (max-height: 640px) {
    h1 {
      margin: 0 0 15px;
    }
    .suggestions {
      margin-top: 10px;
    }
    .suggestion-header {
      margin-bottom: 0;
    }
  }
  
  #download-link,
  #download-link-clicked {
    margin-bottom: 30px;
    margin-top: 30px;
  }
  
  #download-link-clicked {
    color: #BBB;
  }
  
  #download-link::before,
  #download-link-clicked::before {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxLjJlbSIgaGVpZ2h0PSIxLjJlbSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNSAyMGgxNHYtMkg1bTE0LTloLTRWM0g5djZINWw3IDcgNy03eiIgZmlsbD0iIzQyODVGNCIvPjwvc3ZnPg==);
    display: inline-block;
    margin-inline-end: 4px;
    vertical-align: -webkit-baseline-middle;
  }
  
  #download-link-clicked::before {
    opacity: 0;
    width: 0;
  }
  
  #offline-content-list-visibility-card {
    border: 1px solid white;
    border-radius: 8px;
    display: flex;
    font-size: .8em;
    justify-content: space-between;
    line-height: 1;
  }
  
  #offline-content-list.list-hidden #offline-content-list-visibility-card {
    border-color: rgb(218, 220, 224);
  }
  
  #offline-content-list-visibility-card > div {
    padding: 1em;
  }
  
  #offline-content-list-title {
    color: var(--google-gray-700);
  }
  
  #offline-content-list-show-text,
  #offline-content-list-hide-text {
    color: rgb(66, 133, 244);
  }
  
  /* Hides the "hide" text div when the offline content list is collapsed/hidden
   * and, alternatively, hides the "show" text div when the offline content list
   * is expanded/shown.
   */
  #offline-content-list.list-hidden #offline-content-list-hide-text,
  #offline-content-list:not(.list-hidden) #offline-content-list-show-text {
    display: none;
  }
  
  /* Controls the animation of the offline content list when it is expanded/shown.
   */
  #offline-content-suggestions {
    /* Max-height has to be set for the height animation to work. The chosen value
     * is a little greater than the maximum height the list will have, when all
     * suggestions have images, so that it is never clamped. This makes so that
     * when the actual height is smaller then the animation is not as smooth.
     */
    max-height: 27em;
    transition: max-height 200ms ease-in, visibility 0s 200ms,
                opacity 200ms 200ms linear;
  }
  
  /* Controls the animation of the offline content list when it is
   * collapsed/hidden.
   */
  #offline-content-list.list-hidden #offline-content-suggestions {
    max-height: 0;
    opacity: 0;
    transition: opacity 200ms linear, visibility 0s 200ms,
                max-height 200ms 200ms ease-out;
    visibility: hidden;
  }
  
  #offline-content-list {
    margin-inline-start: -5%;
    width: 110%;
  }
  
  /* The selectors below adjust the "overflow" of the suggestion cards contents
   * based on the same screen size based strategy used for the main frame, which
   * is applied by the `interstitial-wrapper` class. */
  @media (max-width: 420px)  {
    #offline-content-list {
      margin-inline-start: -2.5%;
      width: 105%;
    }
  }
  @media (max-width: 420px) and (orientation: portrait),
         (max-height: 560px) {
    #offline-content-list {
      margin-inline-start: -12px;
      width: calc(100% + 24px);
    }
  }
  
  .suggestion-with-image .offline-content-suggestion-thumbnail {
    flex-basis: 8.2em;
    flex-shrink: 0;
  }
  
  .suggestion-with-image .offline-content-suggestion-thumbnail > img {
    height: 100%;
    width: 100%;
  }
  
  .suggestion-with-image #offline-content-list:not(.is-rtl)
  .offline-content-suggestion-thumbnail > img {
    border-bottom-right-radius: 7px;
    border-top-right-radius: 7px;
  }
  
  .suggestion-with-image #offline-content-list.is-rtl
  .offline-content-suggestion-thumbnail > img {
    border-bottom-left-radius: 7px;
    border-top-left-radius: 7px;
  }
  
  .suggestion-with-icon .offline-content-suggestion-thumbnail {
    align-items: center;
    display: flex;
    justify-content: center;
    min-height: 4.2em;
    min-width: 4.2em;
  }
  
  .suggestion-with-icon .offline-content-suggestion-thumbnail > div {
    align-items: center;
    background-color: rgb(241, 243, 244);
    border-radius: 50%;
    display: flex;
    height: 2.3em;
    justify-content: center;
    width: 2.3em;
  }
  
  .suggestion-with-icon .offline-content-suggestion-thumbnail > div > img {
    height: 1.45em;
    width: 1.45em;
  }
  
  .offline-content-suggestion-favicon {
    height: 1em;
    margin-inline-end: 0.4em;
    width: 1.4em;
  }
  
  .offline-content-suggestion-favicon > img {
    height: 1.4em;
    width: 1.4em;
  }
  
  .no-favicon .offline-content-suggestion-favicon {
    display: none;
  }
  
  .image-video {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTcgMTAuNVY3YTEgMSAwIDAgMC0xLTFINGExIDEgMCAwIDAtMSAxdjEwYTEgMSAwIDAgMCAxIDFoMTJhMSAxIDAgMCAwIDEtMXYtMy41bDQgNHYtMTFsLTQgNHoiIGZpbGw9IiMzQzQwNDMiLz48L3N2Zz4=);
  }
  
  .image-music-note {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgM3Y5LjI2Yy0uNS0uMTctMS0uMjYtMS41LS4yNkM4IDEyIDYgMTQgNiAxNi41UzggMjEgMTAuNSAyMXM0LjUtMiA0LjUtNC41VjZoNFYzaC03eiIgZmlsbD0iIzNDNDA0MyIvPjwvc3ZnPg==);
  }
  
  .image-earth {
    content: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTIgMmM1LjUyIDAgMTAgNC40OCAxMCAxMHMtNC40OCAxMC0xMCAxMFMyIDE3LjUyIDIgMTIgNi40OCAyIDEyIDJ6TTQgMTJoNC40YzMuNDA3LjAyMiA0LjkyMiAxLjczIDQuNTQzIDUuMTI3SDkuNDg4djIuNDdhOC4wMDQgOC4wMDQgMCAwIDAgMTAuNDk4LTguMDgzQzE5LjMyNyAxMi41MDQgMTguMzMyIDEzIDE3IDEzYy0yLjEzNyAwLTMuMjA2LS45MTYtMy4yMDYtMi43NWgtMy43NDhjLS4yNzQtMi43MjguNjgzLTQuMDkyIDIuODctNC4wOTIgMC0uOTc1LjMyNy0xLjU5Ny44MTEtMS45N0E4LjAwNCA4LjAwNCAwIDAgMCA0IDEyeiIgZmlsbD0iIzNDNDA0MyIvPjwvc3ZnPg==);
  }
  
  .image-file {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTMgOVYzLjVMMTguNSA5TTYgMmMtMS4xMSAwLTIgLjg5LTIgMnYxNmEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJWOGwtNi02SDZ6IiBmaWxsPSIjM0M0MDQzIi8+PC9zdmc+);
  }
  
  .offline-content-suggestion-texts {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    line-height: 1.3;
    padding: .9em;
    width: 100%;
  }
  
  .offline-content-suggestion-title {
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
    color: rgb(32, 33, 36);
    display: -webkit-box;
    font-size: 1.1em;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  div.offline-content-suggestion {
    align-items: stretch;
    border: 1px solid rgb(218, 220, 224);
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    margin-bottom: .8em;
  }
  
  .suggestion-with-image {
    flex-direction: row;
    height: 8.2em;
    max-height: 8.2em;
  }
  
  .suggestion-with-icon {
    flex-direction: row-reverse;
    height: 4.2em;
    max-height: 4.2em;
  }
  
  .suggestion-with-icon .offline-content-suggestion-title {
    -webkit-line-clamp: 1;
    word-break: break-all;
  }
  
  .suggestion-with-icon .offline-content-suggestion-texts {
    padding-inline-start: 0;
  }
  
  .offline-content-suggestion-attribution-freshness {
    color: rgb(95, 99, 104);
    display: flex;
    font-size: .8em;
    line-height: 1.7em;
  }
  
  .offline-content-suggestion-attribution {
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
    display: -webkit-box;
    flex-shrink: 1;
    margin-inline-end: 0.3em;
    overflow: hidden;
    overflow-wrap: break-word;
    text-overflow: ellipsis;
    word-break: break-all;
  }
  
  .no-attribution .offline-content-suggestion-attribution {
    display: none;
  }
  
  .offline-content-suggestion-freshness::before {
    content: '-';
    display: inline-block;
    flex-shrink: 0;
    margin-inline-end: .1em;
    margin-inline-start: .1em;
  }
  
  .no-attribution .offline-content-suggestion-freshness::before {
    display: none;
  }
  
  .offline-content-suggestion-freshness {
    flex-shrink: 0;
  }
  
  .suggestion-with-image .offline-content-suggestion-pin-spacer {
    flex-grow: 100;
    flex-shrink: 1;
  }
  
  .suggestion-with-image .offline-content-suggestion-pin {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIDBoMjR2MjRIMFYweiIvPjwvZGVmcz48Y2xpcFBhdGggaWQ9ImIiPjx1c2UgeGxpbms6aHJlZj0iI2EiIG92ZXJmbG93PSJ2aXNpYmxlIi8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjYikiIGQ9Ik0xMiAyQzYuNSAyIDIgNi41IDIgMTJzNC41IDEwIDEwIDEwIDEwLTQuNSAxMC0xMFMxNy41IDIgMTIgMnptNSAxNkg3di0yaDEwdjJ6bS02LjctNEw3IDEwLjdsMS40LTEuNCAxLjkgMS45IDUuMy01LjNMMTcgNy4zIDEwLjMgMTR6IiBmaWxsPSIjOUFBMEE2Ii8+PC9zdmc+);
    flex-shrink: 0;
    height: 1.4em;
    margin-inline-start: .4em;
    width: 1.4em;
  }
  
  /* Controls the animation (and a bit more) of the launch-downloads-home action
   * button when the offline content list is expanded/shown.
   */
  #offline-content-list-action {
    text-align: center;
    transition: visibility 0s 200ms, opacity 200ms 200ms linear;
  }
  
  /* Controls the animation of the launch-downloads-home action button when the
   * offline content list is collapsed/hidden.
   */
  #offline-content-list.list-hidden #offline-content-list-action {
    opacity: 0;
    transition: opacity 200ms linear, visibility 0s 200ms;
    visibility: hidden;
  }
  
  #cancel-save-page-button {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48Y2xpcFBhdGggaWQ9Im1hc2siPjxwYXRoIGQ9Ik0xMiAyQzYuNSAyIDIgNi41IDIgMTJzNC41IDEwIDEwIDEwIDEwLTQuNSAxMC0xMFMxNy41IDIgMTIgMnptNSAxNkg3di0yaDEwdjJ6bS02LjctNEw3IDEwLjdsMS40LTEuNCAxLjkgMS45IDUuMy01LjNMMTcgNy4zIDEwLjMgMTR6IiBmaWxsPSIjOUFBMEE2Ii8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiM5QUEwQTYiIGQ9Ik0wIDBoMjR2MjRIMHoiLz48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiMxQTczRTgiIHN0eWxlPSJhbmltYXRpb246b2ZmbGluZUFuaW1hdGlvbiA0cyBpbmZpbml0ZSIgZD0iTTAgMGgyNHYyNEgweiIvPjxzdHlsZT5Aa2V5ZnJhbWVzIG9mZmxpbmVBbmltYXRpb257MCUsMzUle2hlaWdodDowfTYwJXtoZWlnaHQ6MTAwJX05MCV7ZmlsbC1vcGFjaXR5OjF9dG97ZmlsbC1vcGFjaXR5OjB9fTwvc3R5bGU+PC9zdmc+);
    background-position: right 27px center;
    background-repeat: no-repeat;
    border: 1px solid var(--google-gray-300);
    border-radius: 5px;
    color: var(--google-gray-700);
    margin-bottom: 26px;
    padding-bottom: 16px;
    padding-inline-end: 88px;
    padding-inline-start: 16px;
    padding-top: 16px;
    text-align: start;
  }
  
  html[dir='rtl'] #cancel-save-page-button {
    background-position: left 27px center;
  }
  
  #save-page-for-later-button {
    display: flex;
    justify-content: start;
  }
  
  #save-page-for-later-button a::before {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxLjJlbSIgaGVpZ2h0PSIxLjJlbSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNSAyMGgxNHYtMkg1bTE0LTloLTRWM0g5djZINWw3IDcgNy03eiIgZmlsbD0iIzQyODVGNCIvPjwvc3ZnPg==);
    display: inline-block;
    margin-inline-end: 4px;
    vertical-align: -webkit-baseline-middle;
  }
  
  .hidden#save-page-for-later-button {
    display: none;
  }
  
  /* Don't allow overflow when in a subframe. */
  html[subframe] body {
    overflow: hidden;
  }
  
  #sub-frame-error {
    -webkit-align-items: center;
    -webkit-flex-flow: column;
    -webkit-justify-content: center;
    background-color: #DDD;
    display: -webkit-flex;
    height: 100%;
    left: 0;
    position: absolute;
    text-align: center;
    top: 0;
    transition: background-color 200ms ease-in-out;
    width: 100%;
  }
  
  #sub-frame-error:hover {
    background-color: #EEE;
  }
  
  #sub-frame-error .icon-generic {
    margin: 0 0 16px;
  }
  
  #sub-frame-error-details {
    margin: 0 10px;
    text-align: center;
    visibility: hidden;
  }
  
  /* Show details only when hovering. */
  #sub-frame-error:hover #sub-frame-error-details {
    visibility: visible;
  }
  
  /* If the iframe is too small, always hide the error code. */
  /* TODO(mmenke): See if overflow: no-display works better, once supported. */
  @media (max-width: 200px), (max-height: 95px) {
    #sub-frame-error-details {
      display: none;
    }
  }
  
  /* Adjust icon for small embedded frames in apps. */
  @media (max-height: 100px) {
    #sub-frame-error .icon-generic {
      height: auto;
      margin: 0;
      padding-top: 0;
      width: 25px;
    }
  }
  
  /* details-button is special; it's a <button> element that looks like a link. */
  #details-button {
    box-shadow: none;
    min-width: 0;
  }
  
  /* Styles for platform dependent separation of controls and details button. */
  .suggested-left > #control-buttons,
  .suggested-right > #details-button {
    float: left;
  }
  
  .suggested-right > #control-buttons,
  .suggested-left > #details-button {
    float: right;
  }
  
  .suggested-left .secondary-button {
    margin-inline-end: 0;
    margin-inline-start: 16px;
  }
  
  #details-button.singular {
    float: none;
  }
  
  /* download-button shows both icon and text. */
  #download-button {
    padding-bottom: 4px;
    padding-top: 4px;
    position: relative;
  }
  
  #download-button::before {
    background: -webkit-image-set(
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAO0lEQVQ4y2NgGArgPxIY1YChsOE/LtBAmpYG0mxpIOSDBpKUo2lpIDZxNJCkHKqlYZAla3RAHQ1DFgAARRroHyLNTwwAAAAASUVORK5CYII=) 1x,
        url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAQAAAD9CzEMAAAAZElEQVRYw+3Ruw3AMAwDUY3OzZUmRRD4E9iim9wNwAdbEURHyk4AAAAATiCVK8lLyPsKeT9K3lsownnunfkPxO78hKiYHxBV8x2icr5BVM+/CMf8g3DN34Rzns6ViwHUAUQ/6wIAd5Km7l6c8AAAAABJRU5ErkJggg==) 2x)
      no-repeat;
    content: '';
    display: inline-block;
    height: 24px;
    margin-inline-end: 4px;
    margin-inline-start: -4px;
    vertical-align: middle;
    width: 24px;
  }
  
  #download-button:disabled {
    background: rgb(180, 206, 249);
    color: rgb(255, 255, 255);
  }
  
  #buttons::after {
    clear: both;
    content: '';
    display: block;
    width: 100%;
  }
  
  /* Offline page */
  html[dir='rtl'] .runner-container,
  html[dir='rtl'].offline .icon-offline {
    transform: scaleX(-1);
  }
  
  .offline {
    transition: filter 1.5s cubic-bezier(0.65, 0.05, 0.36, 1),
                background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
  
    will-change: filter, background-color;
  
  }
  
  .offline body {
    transition: background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
  }
  
  .offline #main-message > p {
    display: none;
  }
  
  .offline.inverted {
    background-color: #fff;
    filter: invert(1);
  }
  
  .offline.inverted body {
    background-color: #fff;
  }
  
  .offline .interstitial-wrapper {
    color: var(--text-color);
    font-size: 1em;
    line-height: 1.55;
    margin: 0 auto;
    max-width: 600px;
    padding-top: 100px;
    position: relative;
    width: 100%;
  }
  
  .offline .runner-container {
    direction: ltr;
    height: 150px;
    max-width: 600px;
    overflow: hidden;
    position: absolute;
    top: 35px;
    width: 44px;
  }
  
  .offline .runner-container:focus {
    outline: none;
  }
  
  .offline .runner-container:focus-visible {
    outline: 3px solid var(--google-blue-300);
  }
  
  .offline .runner-canvas {
    height: 150px;
    max-width: 600px;
    opacity: 1;
    overflow: hidden;
    position: absolute;
    top: 0;
    z-index: 10;
  }
  
  .offline .controller {
    height: 100vh;
    left: 0;
    position: absolute;
    top: 0;
    width: 100vw;
    z-index: 9;
  }
  
  #offline-resources {
    display: none;
  }
  
  #offline-instruction {
    image-rendering: pixelated;
    left: 0;
    margin: auto;
    position: absolute;
    right: 0;
    top: 60px;
    width: fit-content;
  }
  
  .offline-runner-live-region {
    bottom: 0;
    clip-path: polygon(0 0, 0 0, 0 0);
    color: var(--background-color);
    display: block;
    font-size: xx-small;
    overflow: hidden;
    position: absolute;
    text-align: center;
    transition: color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
    user-select: none;
  }
  
  /* Custom toggle */
  .slow-speed-option {
    align-items: center;
    background: var(--google-gray-50);
    border-radius: 24px/50%;
    bottom: 0;
    color: var(--error-code-color);
    display: inline-flex;
    font-size: 1em;
    left: 0;
    line-height: 1.1em;
    margin: 5px auto;
    padding: 2px 12px 3px 20px;
    position: absolute;
    right: 0;
    width: max-content;
    z-index: 999;
  }
  
  .slow-speed-option.hidden {
    display: none;
  }
  
  .slow-speed-option [type=checkbox] {
    opacity: 0;
    pointer-events: none;
    position: absolute;
  }
  
  .slow-speed-option .slow-speed-toggle {
    cursor: pointer;
    margin-inline-start: 8px;
    padding: 8px 4px;
    position: relative;
  }
  
  .slow-speed-option [type=checkbox]:disabled ~ .slow-speed-toggle {
    cursor: default;
  }
  
  .slow-speed-option-label [type=checkbox] {
    opacity: 0;
    pointer-events: none;
    position: absolute;
  }
  
  .slow-speed-option .slow-speed-toggle::before,
  .slow-speed-option .slow-speed-toggle::after {
    content: '';
    display: block;
    margin: 0 3px;
    transition: all 100ms cubic-bezier(0.4, 0, 1, 1);
  }
  
  .slow-speed-option .slow-speed-toggle::before {
    background: rgb(189,193,198);
    border-radius: 0.65em;
    height: 0.9em;
    width: 2em;
  }
  
  .slow-speed-option .slow-speed-toggle::after {
    background: #fff;
    border-radius: 50%;
    box-shadow: 0 1px 3px 0 rgb(0 0 0 / 40%);
    height: 1.2em;
    position: absolute;
    top: 51%;
    transform: translate(-20%, -50%);
    width: 1.1em;
  }
  
  .slow-speed-option [type=checkbox]:focus + .slow-speed-toggle {
    box-shadow: 0 0 8px rgb(94, 158, 214);
    outline: 1px solid rgb(93, 157, 213);
  }
  
  .slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::before {
    background: var(--google-blue-600);
    opacity: 0.5;
  }
  
  .slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::after {
    background: var(--google-blue-600);
    transform: translate(calc(2em - 90%), -50%);
  }
  
  .slow-speed-option [type=checkbox]:checked:disabled +
    .slow-speed-toggle::before {
    background: rgb(189,193,198);
  }
  
  .slow-speed-option [type=checkbox]:checked:disabled +
    .slow-speed-toggle::after {
    background: var(--google-gray-50);
  }
  
  @media (max-width: 420px) {
    #download-button {
      padding-bottom: 12px;
      padding-top: 12px;
    }
  
    .suggested-left > #control-buttons,
    .suggested-right > #control-buttons {
      float: none;
    }
  
    .snackbar {
      border-radius: 0;
      bottom: 0;
      left: 0;
      width: 100%;
    }
  }
  
  @media (max-height: 350px) {
    h1 {
      margin: 0 0 15px;
    }
  
    .icon-offline {
      margin: 0 0 10px;
    }
  
    .interstitial-wrapper {
      margin-top: 5%;
    }
  
    .nav-wrapper {
      margin-top: 30px;
    }
  }
  
  @media (min-width: 420px) and (max-width: 736px) and
         (min-height: 240px) and (max-height: 420px) and
         (orientation:landscape) {
    .interstitial-wrapper {
      margin-bottom: 100px;
    }
  }
  
  @media (max-width: 360px) and (max-height: 480px) {
    .offline .interstitial-wrapper {
      padding-top: 60px;
    }
  
    .offline .runner-container {
      top: 8px;
    }
  }
  
  @media (min-height: 240px) and (orientation: landscape) {
    .offline .interstitial-wrapper {
      margin-bottom: 90px;
    }
  
    .icon-offline {
      margin-bottom: 20px;
    }
  }
  
  @media (max-height: 320px) and (orientation: landscape) {
    .icon-offline {
      margin-bottom: 0;
    }
  
    .offline .runner-container {
      top: 10px;
    }
  }
  
  @media (max-width: 240px) {
    button {
      padding-inline-end: 12px;
      padding-inline-start: 12px;
    }
  
    .interstitial-wrapper {
      overflow: inherit;
      padding: 0 8px;
    }
  }
  
  @media (max-width: 120px) {
    button {
      width: auto;
    }
  }
  
  .arcade-mode,
  .arcade-mode .runner-container,
  .arcade-mode .runner-canvas {
    image-rendering: pixelated;
    max-width: 100%;
    overflow: hidden;
  }
  
  .arcade-mode #buttons,
  .arcade-mode #main-content {
    opacity: 0;
    overflow: hidden;
  }
  
  .arcade-mode .interstitial-wrapper {
    height: 100vh;
    max-width: 100%;
    overflow: hidden;
  }
  
  .arcade-mode .runner-container {
    left: 0;
    margin: auto;
    right: 0;
    transform-origin: top center;
    transition: transform 250ms cubic-bezier(0.4, 0, 1, 1) 400ms;
    z-index: 2;
  }
  
  @media (prefers-color-scheme: dark) {
    .icon {
      filter: invert(1);
    }
  
    .offline .runner-canvas {
      filter: invert(1);
    }
  
    .offline.inverted {
      background-color: var(--background-color);
      filter: invert(0);
    }
  
    .offline.inverted body {
      background-color: #fff;
    }
  
    .offline.inverted .offline-runner-live-region {
      color: #fff;
    }
  
    #suggestions-list a {
      color: var(--link-color);
    }
  
    #error-information-button {
      filter: invert(0.6);
    }
  
    .slow-speed-option {
      background: var(--google-gray-800);
      color: var(--google-gray-100);
    }
  
    .slow-speed-option .slow-speed-toggle::before,
    .slow-speed-option [type=checkbox]:checked:disabled +
      .slow-speed-toggle::before {
       background: rgb(189,193,198);
    }
  
    .slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::after,
    .slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::before {
      background: var(--google-blue-300);
    }
  }
  </style>
    <script>// Copyright 2013 The Chromium Authors
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.
  
  /**
   * @typedef {{
   *   downloadButtonClick: function(),
   *   reloadButtonClick: function(string),
   *   detailsButtonClick: function(),
   *   diagnoseErrorsButtonClick: function(),
   *   trackEasterEgg: function(),
   *   updateEasterEggHighScore: function(number),
   *   resetEasterEggHighScore: function(),
   *   launchOfflineItem: function(string, string),
   *   savePageForLater: function(),
   *   cancelSavePage: function(),
   *   listVisibilityChange: function(boolean),
   * }}
   */
  // eslint-disable-next-line no-var
  var errorPageController;
  
  const HIDDEN_CLASS = 'hidden';
  
  // Decodes a UTF16 string that is encoded as base64.
  function decodeUTF16Base64ToString(encoded_text) {
    const data = atob(encoded_text);
    let result = '';
    for (let i = 0; i < data.length; i += 2) {
      result +=
          String.fromCharCode(data.charCodeAt(i) * 256 + data.charCodeAt(i + 1));
    }
    return result;
  }
  
  function toggleHelpBox() {
    const helpBoxOuter = document.getElementById('details');
    helpBoxOuter.classList.toggle(HIDDEN_CLASS);
    const detailsButton = document.getElementById('details-button');
    if (helpBoxOuter.classList.contains(HIDDEN_CLASS)) {
      /** @suppress {missingProperties} */
      detailsButton.innerText = detailsButton.detailsText;
    } else {
      /** @suppress {missingProperties} */
      detailsButton.innerText = detailsButton.hideDetailsText;
    }
  
    // Details appears over the main content on small screens.
    if (mobileNav) {
      document.getElementById('main-content').classList.toggle(HIDDEN_CLASS);
      const runnerContainer = document.querySelector('.runner-container');
      if (runnerContainer) {
        runnerContainer.classList.toggle(HIDDEN_CLASS);
      }
    }
  }
  
  function diagnoseErrors() {
    if (window.errorPageController) {
      errorPageController.diagnoseErrorsButtonClick();
    }
  }
  
  // Subframes use a different layout but the same html file.  This is to make it
  // easier to support platforms that load the error page via different
  // mechanisms (Currently just iOS). We also use the subframe style for portals
  // as they are embedded like subframes and can't be interacted with by the user.
  let isSubFrame = false;
  if (window.top.location !== window.location || window.portalHost) {
    document.documentElement.setAttribute('subframe', '');
    isSubFrame = true;
  }
  
  // Re-renders the error page using |strings| as the dictionary of values.
  // Used by NetErrorTabHelper to update DNS error pages with probe results.
  function updateForDnsProbe(strings) {
    const context = new JsEvalContext(strings);
    jstProcess(context, document.getElementById('t'));
    onDocumentLoadOrUpdate();
  }
  
  // Adds an icon class to the list and removes classes previously set.
  function updateIconClass(newClass) {
    const frameSelector = isSubFrame ? '#sub-frame-error' : '#main-frame-error';
    const iconEl = document.querySelector(frameSelector + ' .icon');
  
    if (iconEl.classList.contains(newClass)) {
      return;
    }
  
    iconEl.className = 'icon ' + newClass;
  }
  
  // Implements button clicks.  This function is needed during the transition
  // between implementing these in trunk chromium and implementing them in iOS.
  function reloadButtonClick(url) {
    if (window.errorPageController) {
      // 
  
      // 
      errorPageController.reloadButtonClick();
      // 
    } else {
      window.location = url;
    }
  }
  
  function downloadButtonClick() {
    if (window.errorPageController) {
      errorPageController.downloadButtonClick();
      const downloadButton = document.getElementById('download-button');
      downloadButton.disabled = true;
      /** @suppress {missingProperties} */
      downloadButton.textContent = downloadButton.disabledText;
  
      document.getElementById('download-link-wrapper')
          .classList.add(HIDDEN_CLASS);
      document.getElementById('download-link-clicked-wrapper')
          .classList.remove(HIDDEN_CLASS);
    }
  }
  
  function detailsButtonClick() {
    if (window.errorPageController) {
      errorPageController.detailsButtonClick();
    }
  }
  
  let primaryControlOnLeft = true;
  // clang-format off
  // 
  
  function setAutoFetchState(scheduled, can_schedule) {
    document.getElementById('cancel-save-page-button')
        .classList.toggle(HIDDEN_CLASS, !scheduled);
    document.getElementById('save-page-for-later-button')
        .classList.toggle(HIDDEN_CLASS, scheduled || !can_schedule);
  }
  
  function savePageLaterClick() {
    errorPageController.savePageForLater();
    // savePageForLater will eventually trigger a call to setAutoFetchState() when
    // it completes.
  }
  
  function cancelSavePageClick() {
    errorPageController.cancelSavePage();
    // setAutoFetchState is not called in response to cancelSavePage(), so do it
    // now.
    setAutoFetchState(false, true);
  }
  
  function toggleErrorInformationPopup() {
    document.getElementById('error-information-popup-container')
        .classList.toggle(HIDDEN_CLASS);
  }
  
  function launchOfflineItem(itemID, name_space) {
    errorPageController.launchOfflineItem(itemID, name_space);
  }
  
  function launchDownloadsPage() {
    errorPageController.launchDownloadsPage();
  }
  
  function getIconForSuggestedItem(item) {
    // Note: |item.content_type| contains the enum values from
    // chrome::mojom::AvailableContentType.
    switch (item.content_type) {
      case 1:  // kVideo
        return 'image-video';
      case 2:  // kAudio
        return 'image-music-note';
      case 0:  // kPrefetchedPage
      case 3:  // kOtherPage
        return 'image-earth';
    }
    return 'image-file';
  }
  
  function getSuggestedContentDiv(item, index) {
    // Note: See AvailableContentToValue in available_offline_content_helper.cc
    // for the data contained in an |item|.
    // TODO(carlosk): Present |snippet_base64| when that content becomes
    // available.
    let thumbnail = '';
    const extraContainerClasses = [];
    // html_inline.py will try to replace src attributes with data URIs using a
    // simple regex. The following is obfuscated slightly to avoid that.
    const source = 'src';
    if (item.thumbnail_data_uri) {
      extraContainerClasses.push('suggestion-with-image');
      thumbnail = `<img ${source}="${item.thumbnail_data_uri}">`;
    } else {
      extraContainerClasses.push('suggestion-with-icon');
      const iconClass = getIconForSuggestedItem(item);
      thumbnail = `<div><img class="${iconClass}"></div>`;
    }
  
    let favicon = '';
    if (item.favicon_data_uri) {
      favicon = `<img ${source}="${item.favicon_data_uri}">`;
    } else {
      extraContainerClasses.push('no-favicon');
    }
  
    if (!item.attribution_base64) {
      extraContainerClasses.push('no-attribution');
    }
  
    return `
    <div class="offline-content-suggestion ${extraContainerClasses.join(' ')}"
      onclick="launchOfflineItem('${item.ID}', '${item.name_space}')">
        <div class="offline-content-suggestion-texts">
          <div id="offline-content-suggestion-title-${index}"
               class="offline-content-suggestion-title">
          </div>
          <div class="offline-content-suggestion-attribution-freshness">
            <div id="offline-content-suggestion-favicon-${index}"
                 class="offline-content-suggestion-favicon">
              ${favicon}
            </div>
            <div id="offline-content-suggestion-attribution-${index}"
                 class="offline-content-suggestion-attribution">
            </div>
            <div class="offline-content-suggestion-freshness">
              ${item.date_modified}
            </div>
            <div class="offline-content-suggestion-pin-spacer"></div>
            <div class="offline-content-suggestion-pin"></div>
          </div>
        </div>
        <div class="offline-content-suggestion-thumbnail">
          ${thumbnail}
        </div>
    </div>`;
  }
  
  /**
   * @typedef {{
   *   ID: string,
   *   name_space: string,
   *   title_base64: string,
   *   snippet_base64: string,
   *   date_modified: string,
   *   attribution_base64: string,
   *   thumbnail_data_uri: string,
   *   favicon_data_uri: string,
   *   content_type: number,
   * }}
   */
  let AvailableOfflineContent;
  
  // Populates a list of suggested offline content.
  // Note: For security reasons all content downloaded from the web is considered
  // unsafe and must be securely handled to be presented on the dino page. Images
  // have already been safely re-encoded but textual content -- like title and
  // attribution -- must be properly handled here.
  // @param {boolean} isShown
  // @param {Array<AvailableOfflineContent>} suggestions
  function offlineContentAvailable(isShown, suggestions) {
    if (!suggestions || !loadTimeData.valueExists('offlineContentList')) {
      return;
    }
  
    const suggestionsHTML = [];
    for (let index = 0; index < suggestions.length; index++) {
      suggestionsHTML.push(getSuggestedContentDiv(suggestions[index], index));
    }
  
    document.getElementById('offline-content-suggestions').innerHTML =
        suggestionsHTML.join('\n');
  
    // Sets textual web content using |textContent| to make sure it's handled as
    // plain text.
    for (let index = 0; index < suggestions.length; index++) {
      document.getElementById(`offline-content-suggestion-title-${index}`)
          .textContent =
          decodeUTF16Base64ToString(suggestions[index].title_base64);
      document.getElementById(`offline-content-suggestion-attribution-${index}`)
          .textContent =
          decodeUTF16Base64ToString(suggestions[index].attribution_base64);
    }
  
    const contentListElement = document.getElementById('offline-content-list');
    if (document.dir === 'rtl') {
      contentListElement.classList.add('is-rtl');
    }
    contentListElement.hidden = false;
    // The list is configured as hidden by default. Show it if needed.
    if (isShown) {
      toggleOfflineContentListVisibility(false);
    }
  }
  
  function toggleOfflineContentListVisibility(updatePref) {
    if (!loadTimeData.valueExists('offlineContentList')) {
      return;
    }
  
    const contentListElement = document.getElementById('offline-content-list');
    const isVisible = !contentListElement.classList.toggle('list-hidden');
  
    if (updatePref && window.errorPageController) {
      errorPageController.listVisibilityChanged(isVisible);
    }
  }
  
  // Called on document load, and from updateForDnsProbe().
  function onDocumentLoadOrUpdate() {
    const downloadButtonVisible = loadTimeData.valueExists('downloadButton') &&
        loadTimeData.getValue('downloadButton').msg;
    const detailsButton = document.getElementById('details-button');
  
    // If offline content suggestions will be visible, the usual buttons will not
    // be presented.
    const offlineContentVisible =
        loadTimeData.valueExists('suggestedOfflineContentPresentation');
    if (offlineContentVisible) {
      document.querySelector('.nav-wrapper').classList.add(HIDDEN_CLASS);
      detailsButton.classList.add(HIDDEN_CLASS);
  
      document.getElementById('download-link').hidden = !downloadButtonVisible;
      document.getElementById('download-links-wrapper')
          .classList.remove(HIDDEN_CLASS);
      document.getElementById('error-information-popup-container')
          .classList.add('use-popup-container', HIDDEN_CLASS);
      document.getElementById('error-information-button')
          .classList.remove(HIDDEN_CLASS);
    }
  
    const attemptAutoFetch = loadTimeData.valueExists('attemptAutoFetch') &&
        loadTimeData.getValue('attemptAutoFetch');
  
    const reloadButtonVisible = loadTimeData.valueExists('reloadButton') &&
        loadTimeData.getValue('reloadButton').msg;
  
    const reloadButton = document.getElementById('reload-button');
    const downloadButton = document.getElementById('download-button');
    if (reloadButton.style.display === 'none' &&
        downloadButton.style.display === 'none') {
      detailsButton.classList.add('singular');
    }
  
    // Show or hide control buttons.
    const controlButtonDiv = document.getElementById('control-buttons');
    controlButtonDiv.hidden =
        offlineContentVisible || !(reloadButtonVisible || downloadButtonVisible);
  
    const iconClass = loadTimeData.valueExists('iconClass') &&
        loadTimeData.getValue('iconClass');
  
    updateIconClass(iconClass);
  
    if (!isSubFrame && iconClass === 'icon-offline') {
      document.documentElement.classList.add('offline');
      new Runner('.interstitial-wrapper');
    }
  }
  
  function onDocumentLoad() {
    // Sets up the proper button layout for the current platform.
    const buttonsDiv = document.getElementById('buttons');
    if (primaryControlOnLeft) {
      buttonsDiv.classList.add('suggested-left');
    } else {
      buttonsDiv.classList.add('suggested-right');
    }
  
    onDocumentLoadOrUpdate();
  }
  
  document.addEventListener('DOMContentLoaded', onDocumentLoad);
  </script>
    <script>// Copyright 2015 The Chromium Authors
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.
  
  let mobileNav = false;
  
  /**
   * For small screen mobile the navigation buttons are moved
   * below the advanced text.
   */
  function onResize() {
    const helpOuterBox = document.querySelector('#details');
    const mainContent = document.querySelector('#main-content');
    const mediaQuery = '(min-width: 240px) and (max-width: 420px) and ' +
        '(min-height: 401px), ' +
        '(max-height: 560px) and (min-height: 240px) and ' +
        '(min-width: 421px)';
  
    const detailsHidden = helpOuterBox.classList.contains(HIDDEN_CLASS);
    const runnerContainer = document.querySelector('.runner-container');
  
    // Check for change in nav status.
    if (mobileNav !== window.matchMedia(mediaQuery).matches) {
      mobileNav = !mobileNav;
  
      // Handle showing the top content / details sections according to state.
      if (mobileNav) {
        mainContent.classList.toggle(HIDDEN_CLASS, !detailsHidden);
        helpOuterBox.classList.toggle(HIDDEN_CLASS, detailsHidden);
        if (runnerContainer) {
          runnerContainer.classList.toggle(HIDDEN_CLASS, !detailsHidden);
        }
      } else if (!detailsHidden) {
        // Non mobile nav with visible details.
        mainContent.classList.remove(HIDDEN_CLASS);
        helpOuterBox.classList.remove(HIDDEN_CLASS);
        if (runnerContainer) {
          runnerContainer.classList.remove(HIDDEN_CLASS);
        }
      }
    }
  }
  
  function setupMobileNav() {
    window.addEventListener('resize', onResize);
    onResize();
  }
  
  document.addEventListener('DOMContentLoaded', setupMobileNav);
  </script>
    <script>// Copyright 2014 The Chromium Authors
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.
  
  /**
   * T-Rex runner.
   * @param {string} outerContainerId Outer containing element id.
   * @param {!Object=} opt_config
   * @constructor
   * @implements {EventListener}
   * @export
   */
  function Runner(outerContainerId, opt_config) {
    // Singleton
    if (Runner.instance_) {
      return Runner.instance_;
    }
    Runner.instance_ = this;
  
    this.outerContainerEl = document.querySelector(outerContainerId);
    this.containerEl = null;
    this.snackbarEl = null;
    // A div to intercept touch events. Only set while (playing && useTouch).
    this.touchController = null;
  
    this.config = opt_config || Object.assign(Runner.config, Runner.normalConfig);
    // Logical dimensions of the container.
    this.dimensions = Runner.defaultDimensions;
  
    this.gameType = null;
    Runner.spriteDefinition = Runner.spriteDefinitionByType['original'];
  
    this.altGameImageSprite = null;
    this.altGameModeActive = false;
    this.altGameModeFlashTimer = null;
    this.fadeInTimer = 0;
  
    this.canvas = null;
    this.canvasCtx = null;
  
    this.tRex = null;
  
    this.distanceMeter = null;
    this.distanceRan = 0;
  
    this.highestScore = 0;
    this.syncHighestScore = false;
  
    this.time = 0;
    this.runningTime = 0;
    this.msPerFrame = 1000 / FPS;
    this.currentSpeed = this.config.SPEED;
    Runner.slowDown = false;
  
    this.obstacles = [];
  
    this.activated = false; // Whether the easter egg has been activated.
    this.playing = false; // Whether the game is currently in play state.
    this.crashed = false;
    this.paused = false;
    this.inverted = false;
    this.invertTimer = 0;
    this.resizeTimerId_ = null;
  
    this.playCount = 0;
  
    // Sound FX.
    this.audioBuffer = null;
  
    /** @type {Object} */
    this.soundFx = {};
    this.generatedSoundFx = null;
  
    // Global web audio context for playing sounds.
    this.audioContext = null;
  
    // Images.
    this.images = {};
    this.imagesLoaded = 0;
  
    // Gamepad state.
    this.pollingGamepads = false;
    this.gamepadIndex = undefined;
    this.previousGamepad = null;
  
    if (this.isDisabled()) {
      this.setupDisabledRunner();
    } else {
      if (Runner.isAltGameModeEnabled()) {
        this.initAltGameType();
        Runner.gameType = this.gameType;
      }
      this.loadImages();
  
      window['initializeEasterEggHighScore'] =
          this.initializeHighScore.bind(this);
    }
  }
  
  /**
   * Default game width.
   * @const
   */
  const DEFAULT_WIDTH = 600;
  
  /**
   * Frames per second.
   * @const
   */
  const FPS = 60;
  
  /** @const */
  const IS_HIDPI = window.devicePixelRatio > 1;
  
  /** @const */
  const IS_IOS = /CriOS/.test(window.navigator.userAgent);
  
  /** @const */
  const IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;
  
  /** @const */
  const IS_RTL = document.querySelector('html').dir == 'rtl';
  
  /** @const */
  const ARCADE_MODE_URL = 'chrome://dino/';
  
  /** @const */
  const RESOURCE_POSTFIX = 'offline-resources-';
  
  /** @const */
  const A11Y_STRINGS = {
    ariaLabel: 'dinoGameA11yAriaLabel',
    description: 'dinoGameA11yDescription',
    gameOver: 'dinoGameA11yGameOver',
    highScore: 'dinoGameA11yHighScore',
    jump: 'dinoGameA11yJump',
    started: 'dinoGameA11yStartGame',
    speedLabel: 'dinoGameA11ySpeedToggle',
  };
  
  /**
   * Default game configuration.
   * Shared config for all  versions of the game. Additional parameters are
   * defined in Runner.normalConfig and Runner.slowConfig.
   */
  Runner.config = {
    AUDIOCUE_PROXIMITY_THRESHOLD: 190,
    AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 250,
    BG_CLOUD_SPEED: 0.2,
    BOTTOM_PAD: 10,
    // Scroll Y threshold at which the game can be activated.
    CANVAS_IN_VIEW_OFFSET: -10,
    CLEAR_TIME: 3000,
    CLOUD_FREQUENCY: 0.5,
    FADE_DURATION: 1,
    FLASH_DURATION: 1000,
    GAMEOVER_CLEAR_TIME: 1200,
    INITIAL_JUMP_VELOCITY: 12,
    INVERT_FADE_DURATION: 12000,
    MAX_BLINK_COUNT: 3,
    MAX_CLOUDS: 6,
    MAX_OBSTACLE_LENGTH: 3,
    MAX_OBSTACLE_DUPLICATION: 2,
    RESOURCE_TEMPLATE_ID: 'audio-resources',
    SPEED: 6,
    SPEED_DROP_COEFFICIENT: 3,
    ARCADE_MODE_INITIAL_TOP_POSITION: 35,
    ARCADE_MODE_TOP_POSITION_PERCENT: 0.1,
  };
  
  Runner.normalConfig = {
    ACCELERATION: 0.001,
    AUDIOCUE_PROXIMITY_THRESHOLD: 190,
    AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 250,
    GAP_COEFFICIENT: 0.6,
    INVERT_DISTANCE: 700,
    MAX_SPEED: 13,
    MOBILE_SPEED_COEFFICIENT: 1.2,
    SPEED: 6,
  };
  
  
  Runner.slowConfig = {
    ACCELERATION: 0.0005,
    AUDIOCUE_PROXIMITY_THRESHOLD: 170,
    AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 220,
    GAP_COEFFICIENT: 0.3,
    INVERT_DISTANCE: 350,
    MAX_SPEED: 9,
    MOBILE_SPEED_COEFFICIENT: 1.5,
    SPEED: 4.2,
  };
  
  
  /**
   * Default dimensions.
   */
  Runner.defaultDimensions = {
    WIDTH: DEFAULT_WIDTH,
    HEIGHT: 150,
  };
  
  
  /**
   * CSS class names.
   * @enum {string}
   */
  Runner.classes = {
    ARCADE_MODE: 'arcade-mode',
    CANVAS: 'runner-canvas',
    CONTAINER: 'runner-container',
    CRASHED: 'crashed',
    ICON: 'icon-offline',
    INVERTED: 'inverted',
    SNACKBAR: 'snackbar',
    SNACKBAR_SHOW: 'snackbar-show',
    TOUCH_CONTROLLER: 'controller',
  };
  
  
  /**
   * Sound FX. Reference to the ID of the audio tag on interstitial page.
   * @enum {string}
   */
  Runner.sounds = {
    BUTTON_PRESS: 'offline-sound-press',
    HIT: 'offline-sound-hit',
    SCORE: 'offline-sound-reached',
  };
  
  
  /**
   * Key code mapping.
   * @enum {Object}
   */
  Runner.keycodes = {
    JUMP: {'38': 1, '32': 1},  // Up, spacebar
    DUCK: {'40': 1},           // Down
    RESTART: {'13': 1},        // Enter
  };
  
  
  /**
   * Runner event names.
   * @enum {string}
   */
  Runner.events = {
    ANIM_END: 'webkitAnimationEnd',
    CLICK: 'click',
    KEYDOWN: 'keydown',
    KEYUP: 'keyup',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    RESIZE: 'resize',
    TOUCHEND: 'touchend',
    TOUCHSTART: 'touchstart',
    VISIBILITY: 'visibilitychange',
    BLUR: 'blur',
    FOCUS: 'focus',
    LOAD: 'load',
    GAMEPADCONNECTED: 'gamepadconnected',
  };
  
  Runner.prototype = {
    /**
     * Initialize alternative game type.
     */
    initAltGameType() {
      if (GAME_TYPE.length > 0) {
        this.gameType = loadTimeData && loadTimeData.valueExists('altGameType') ?
            GAME_TYPE[parseInt(loadTimeData.getValue('altGameType'), 10) - 1] :
            '';
      }
    },
  
    /**
     * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.
     * @return {boolean}
     */
    isDisabled() {
      return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');
    },
  
    /**
     * For disabled instances, set up a snackbar with the disabled message.
     */
    setupDisabledRunner() {
      this.containerEl = document.createElement('div');
      this.containerEl.className = Runner.classes.SNACKBAR;
      this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');
      this.outerContainerEl.appendChild(this.containerEl);
  
      // Show notification when the activation key is pressed.
      document.addEventListener(Runner.events.KEYDOWN, function(e) {
        if (Runner.keycodes.JUMP[e.keyCode]) {
          this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);
          document.querySelector('.icon').classList.add('icon-disabled');
        }
      }.bind(this));
    },
  
    /**
     * Setting individual settings for debugging.
     * @param {string} setting
     * @param {number|string} value
     */
    updateConfigSetting(setting, value) {
      if (setting in this.config && value !== undefined) {
        this.config[setting] = value;
  
        switch (setting) {
          case 'GRAVITY':
          case 'MIN_JUMP_HEIGHT':
          case 'SPEED_DROP_COEFFICIENT':
            this.tRex.config[setting] = value;
            break;
          case 'INITIAL_JUMP_VELOCITY':
            this.tRex.setJumpVelocity(value);
            break;
          case 'SPEED':
            this.setSpeed(/** @type {number} */ (value));
            break;
        }
      }
    },
  
    /**
     * Creates an on page image element from the base 64 encoded string source.
     * @param {string} resourceName Name in data object,
     * @return {HTMLImageElement} The created element.
     */
    createImageElement(resourceName) {
      const imgSrc = loadTimeData && loadTimeData.valueExists(resourceName) ?
          loadTimeData.getString(resourceName) :
          null;
  
      if (imgSrc) {
        const el =
            /** @type {HTMLImageElement} */ (document.createElement('img'));
        el.id = resourceName;
        el.src = imgSrc;
        document.getElementById('offline-resources').appendChild(el);
        return el;
      }
      return null;
    },
  
    /**
     * Cache the appropriate image sprite from the page and get the sprite sheet
     * definition.
     */
    loadImages() {
      let scale = '1x';
      this.spriteDef = Runner.spriteDefinition.LDPI;
      if (IS_HIDPI) {
        scale = '2x';
        this.spriteDef = Runner.spriteDefinition.HDPI;
      }
  
      Runner.imageSprite = /** @type {HTMLImageElement} */
          (document.getElementById(RESOURCE_POSTFIX + scale));
  
      if (this.gameType) {
        Runner.altGameImageSprite = /** @type {HTMLImageElement} */
            (this.createImageElement('altGameSpecificImage' + scale));
        Runner.altCommonImageSprite = /** @type {HTMLImageElement} */
            (this.createImageElement('altGameCommonImage' + scale));
      }
      Runner.origImageSprite = Runner.imageSprite;
  
      // Disable the alt game mode if the sprites can't be loaded.
      if (!Runner.altGameImageSprite || !Runner.altCommonImageSprite) {
        Runner.isAltGameModeEnabled = () => false;
        this.altGameModeActive = false;
      }
  
      if (Runner.imageSprite.complete) {
        this.init();
      } else {
        // If the images are not yet loaded, add a listener.
        Runner.imageSprite.addEventListener(Runner.events.LOAD,
            this.init.bind(this));
      }
    },
  
    /**
     * Load and decode base 64 encoded sounds.
     */
    loadSounds() {
      if (!IS_IOS) {
        this.audioContext = new AudioContext();
  
        const resourceTemplate =
            document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;
  
        for (const sound in Runner.sounds) {
          let soundSrc =
              resourceTemplate.getElementById(Runner.sounds[sound]).src;
          soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);
          const buffer = decodeBase64ToArrayBuffer(soundSrc);
  
          // Async, so no guarantee of order in array.
          this.audioContext.decodeAudioData(buffer, function(index, audioData) {
              this.soundFx[index] = audioData;
            }.bind(this, sound));
        }
      }
    },
  
    /**
     * Sets the game speed. Adjust the speed accordingly if on a smaller screen.
     * @param {number=} opt_speed
     */
    setSpeed(opt_speed) {
      const speed = opt_speed || this.currentSpeed;
  
      // Reduce the speed on smaller mobile screens.
      if (this.dimensions.WIDTH < DEFAULT_WIDTH) {
        const mobileSpeed = Runner.slowDown ? speed :
                                              speed * this.dimensions.WIDTH /
                DEFAULT_WIDTH * this.config.MOBILE_SPEED_COEFFICIENT;
        this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;
      } else if (opt_speed) {
        this.currentSpeed = opt_speed;
      }
    },
  
    /**
     * Game initialiser.
     */
    init() {
      // Hide the static icon.
      document.querySelector('.' + Runner.classes.ICON).style.visibility =
          'hidden';
  
      this.adjustDimensions();
      this.setSpeed();
  
      const ariaLabel = getA11yString(A11Y_STRINGS.ariaLabel);
      this.containerEl = document.createElement('div');
      this.containerEl.setAttribute('role', IS_MOBILE ? 'button' : 'application');
      this.containerEl.setAttribute('tabindex', '0');
      this.containerEl.setAttribute('title', ariaLabel);
  
      this.containerEl.className = Runner.classes.CONTAINER;
  
      // Player canvas container.
      this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,
          this.dimensions.HEIGHT);
  
      // Live region for game status updates.
      this.a11yStatusEl = document.createElement('span');
      this.a11yStatusEl.className = 'offline-runner-live-region';
      this.a11yStatusEl.setAttribute('aria-live', 'assertive');
      this.a11yStatusEl.textContent = '';
      Runner.a11yStatusEl = this.a11yStatusEl;
  
      // Add checkbox to slow down the game.
      this.slowSpeedCheckboxLabel = document.createElement('label');
      this.slowSpeedCheckboxLabel.className = 'slow-speed-option hidden';
      this.slowSpeedCheckboxLabel.textContent =
          getA11yString(A11Y_STRINGS.speedLabel);
  
      this.slowSpeedCheckbox = document.createElement('input');
      this.slowSpeedCheckbox.setAttribute('type', 'checkbox');
      this.slowSpeedCheckbox.setAttribute(
          'title', getA11yString(A11Y_STRINGS.speedLabel));
      this.slowSpeedCheckbox.setAttribute('tabindex', '0');
      this.slowSpeedCheckbox.setAttribute('checked', 'checked');
  
      this.slowSpeedToggleEl = document.createElement('span');
      this.slowSpeedToggleEl.className = 'slow-speed-toggle';
  
      this.slowSpeedCheckboxLabel.appendChild(this.slowSpeedCheckbox);
      this.slowSpeedCheckboxLabel.appendChild(this.slowSpeedToggleEl);
  
      if (IS_IOS) {
        this.outerContainerEl.appendChild(this.a11yStatusEl);
      } else {
        this.containerEl.appendChild(this.a11yStatusEl);
      }
  
      announcePhrase(getA11yString(A11Y_STRINGS.description));
  
      this.generatedSoundFx = new GeneratedSoundFx();
  
      this.canvasCtx =
          /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
      this.canvasCtx.fillStyle = '#f7f7f7';
      this.canvasCtx.fill();
      Runner.updateCanvasScaling(this.canvas);
  
      // Horizon contains clouds, obstacles and the ground.
      this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,
          this.config.GAP_COEFFICIENT);
  
      // Distance meter
      this.distanceMeter = new DistanceMeter(this.canvas,
            this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);
  
      // Draw t-rex
      this.tRex = new Trex(this.canvas, this.spriteDef.TREX);
  
      this.outerContainerEl.appendChild(this.containerEl);
      this.outerContainerEl.appendChild(this.slowSpeedCheckboxLabel);
  
      this.startListening();
      this.update();
  
      window.addEventListener(Runner.events.RESIZE,
          this.debounceResize.bind(this));
  
      // Handle dark mode
      const darkModeMediaQuery =
          window.matchMedia('(prefers-color-scheme: dark)');
      this.isDarkMode = darkModeMediaQuery && darkModeMediaQuery.matches;
      darkModeMediaQuery.addListener((e) => {
        this.isDarkMode = e.matches;
      });
    },
  
    /**
     * Create the touch controller. A div that covers whole screen.
     */
    createTouchController() {
      this.touchController = document.createElement('div');
      this.touchController.className = Runner.classes.TOUCH_CONTROLLER;
      this.touchController.addEventListener(Runner.events.TOUCHSTART, this);
      this.touchController.addEventListener(Runner.events.TOUCHEND, this);
      this.outerContainerEl.appendChild(this.touchController);
    },
  
    /**
     * Debounce the resize event.
     */
    debounceResize() {
      if (!this.resizeTimerId_) {
        this.resizeTimerId_ =
            setInterval(this.adjustDimensions.bind(this), 250);
      }
    },
  
    /**
     * Adjust game space dimensions on resize.
     */
    adjustDimensions() {
      clearInterval(this.resizeTimerId_);
      this.resizeTimerId_ = null;
  
      const boxStyles = window.getComputedStyle(this.outerContainerEl);
      const padding = Number(boxStyles.paddingLeft.substr(0,
          boxStyles.paddingLeft.length - 2));
  
      this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;
      if (this.isArcadeMode()) {
        this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);
        if (this.activated) {
          this.setArcadeModeContainerScale();
        }
      }
  
      // Redraw the elements back onto the canvas.
      if (this.canvas) {
        this.canvas.width = this.dimensions.WIDTH;
        this.canvas.height = this.dimensions.HEIGHT;
  
        Runner.updateCanvasScaling(this.canvas);
  
        this.distanceMeter.calcXPos(this.dimensions.WIDTH);
        this.clearCanvas();
        this.horizon.update(0, 0, true);
        this.tRex.update(0);
  
        // Outer container and distance meter.
        if (this.playing || this.crashed || this.paused) {
          this.containerEl.style.width = this.dimensions.WIDTH + 'px';
          this.containerEl.style.height = this.dimensions.HEIGHT + 'px';
          this.distanceMeter.update(0, Math.ceil(this.distanceRan));
          this.stop();
        } else {
          this.tRex.draw(0, 0);
        }
  
        // Game over panel.
        if (this.crashed && this.gameOverPanel) {
          this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);
          this.gameOverPanel.draw(this.altGameModeActive, this.tRex);
        }
      }
    },
  
    /**
     * Play the game intro.
     * Canvas container width expands out to the full width.
     */
    playIntro() {
      if (!this.activated && !this.crashed) {
        this.playingIntro = true;
        this.tRex.playingIntro = true;
  
        // CSS animation definition.
        const keyframes = '@-webkit-keyframes intro { ' +
              'from { width:' + Trex.config.WIDTH + 'px }' +
              'to { width: ' + this.dimensions.WIDTH + 'px }' +
            '}';
        document.styleSheets[0].insertRule(keyframes, 0);
  
        this.containerEl.addEventListener(Runner.events.ANIM_END,
            this.startGame.bind(this));
  
        this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';
        this.containerEl.style.width = this.dimensions.WIDTH + 'px';
  
        this.setPlayStatus(true);
        this.activated = true;
      } else if (this.crashed) {
        this.restart();
      }
    },
  
  
    /**
     * Update the game status to started.
     */
    startGame() {
      if (this.isArcadeMode()) {
        this.setArcadeMode();
      }
      this.toggleSpeed();
      this.runningTime = 0;
      this.playingIntro = false;
      this.tRex.playingIntro = false;
      this.containerEl.style.webkitAnimation = '';
      this.playCount++;
      this.generatedSoundFx.background();
      announcePhrase(getA11yString(A11Y_STRINGS.started));
  
      if (Runner.audioCues) {
        this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump));
      }
  
      // Handle tabbing off the page. Pause the current game.
      document.addEventListener(Runner.events.VISIBILITY,
            this.onVisibilityChange.bind(this));
  
      window.addEventListener(Runner.events.BLUR,
            this.onVisibilityChange.bind(this));
  
      window.addEventListener(Runner.events.FOCUS,
            this.onVisibilityChange.bind(this));
    },
  
    clearCanvas() {
      this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,
          this.dimensions.HEIGHT);
    },
  
    /**
     * Checks whether the canvas area is in the viewport of the browser
     * through the current scroll position.
     * @return boolean.
     */
    isCanvasInView() {
      return this.containerEl.getBoundingClientRect().top >
          Runner.config.CANVAS_IN_VIEW_OFFSET;
    },
  
    /**
     * Enable the alt game mode. Switching out the sprites.
     */
    enableAltGameMode() {
      Runner.imageSprite = Runner.altGameImageSprite;
      Runner.spriteDefinition = Runner.spriteDefinitionByType[Runner.gameType];
  
      if (IS_HIDPI) {
        this.spriteDef = Runner.spriteDefinition.HDPI;
      } else {
        this.spriteDef = Runner.spriteDefinition.LDPI;
      }
  
      this.altGameModeActive = true;
      this.tRex.enableAltGameMode(this.spriteDef.TREX);
      this.horizon.enableAltGameMode(this.spriteDef);
      this.generatedSoundFx.background();
    },
  
    /**
     * Update the game frame and schedules the next one.
     */
    update() {
      this.updatePending = false;
  
      const now = getTimeStamp();
      let deltaTime = now - (this.time || now);
  
      // Flashing when switching game modes.
      if (this.altGameModeFlashTimer < 0 || this.altGameModeFlashTimer === 0) {
        this.altGameModeFlashTimer = null;
        this.tRex.setFlashing(false);
        this.enableAltGameMode();
      } else if (this.altGameModeFlashTimer > 0) {
        this.altGameModeFlashTimer -= deltaTime;
        this.tRex.update(deltaTime);
        deltaTime = 0;
      }
  
      this.time = now;
  
      if (this.playing) {
        this.clearCanvas();
  
        // Additional fade in - Prevents jump when switching sprites
        if (this.altGameModeActive &&
            this.fadeInTimer <= this.config.FADE_DURATION) {
          this.fadeInTimer += deltaTime / 1000;
          this.canvasCtx.globalAlpha = this.fadeInTimer;
        } else {
          this.canvasCtx.globalAlpha = 1;
        }
  
        if (this.tRex.jumping) {
          this.tRex.updateJump(deltaTime);
        }
  
        this.runningTime += deltaTime;
        const hasObstacles = this.runningTime > this.config.CLEAR_TIME;
  
        // First jump triggers the intro.
        if (this.tRex.jumpCount === 1 && !this.playingIntro) {
          this.playIntro();
        }
  
        // The horizon doesn't move until the intro is over.
        if (this.playingIntro) {
          this.horizon.update(0, this.currentSpeed, hasObstacles);
        } else if (!this.crashed) {
          const showNightMode = this.isDarkMode ^ this.inverted;
          deltaTime = !this.activated ? 0 : deltaTime;
          this.horizon.update(
              deltaTime, this.currentSpeed, hasObstacles, showNightMode);
        }
  
        // Check for collisions.
        let collision = hasObstacles &&
            checkForCollision(this.horizon.obstacles[0], this.tRex);
  
        // For a11y, audio cues.
        if (Runner.audioCues && hasObstacles) {
          const jumpObstacle =
              this.horizon.obstacles[0].typeConfig.type != 'COLLECTABLE';
  
          if (!this.horizon.obstacles[0].jumpAlerted) {
            const threshold = Runner.isMobileMouseInput ?
                Runner.config.AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y :
                Runner.config.AUDIOCUE_PROXIMITY_THRESHOLD;
            const adjProximityThreshold = threshold +
                (threshold * Math.log10(this.currentSpeed / Runner.config.SPEED));
  
            if (this.horizon.obstacles[0].xPos < adjProximityThreshold) {
              if (jumpObstacle) {
                this.generatedSoundFx.jump();
              }
              this.horizon.obstacles[0].jumpAlerted = true;
            }
          }
        }
  
        // Activated alt game mode.
        if (Runner.isAltGameModeEnabled() && collision &&
            this.horizon.obstacles[0].typeConfig.type == 'COLLECTABLE') {
          this.horizon.removeFirstObstacle();
          this.tRex.setFlashing(true);
          collision = false;
          this.altGameModeFlashTimer = this.config.FLASH_DURATION;
          this.runningTime = 0;
          this.generatedSoundFx.collect();
        }
  
        if (!collision) {
          this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;
  
          if (this.currentSpeed < this.config.MAX_SPEED) {
            this.currentSpeed += this.config.ACCELERATION;
          }
        } else {
          this.gameOver();
        }
  
        const playAchievementSound = this.distanceMeter.update(deltaTime,
            Math.ceil(this.distanceRan));
  
        if (!Runner.audioCues && playAchievementSound) {
          this.playSound(this.soundFx.SCORE);
        }
  
        // Night mode.
        if (!Runner.isAltGameModeEnabled()) {
          if (this.invertTimer > this.config.INVERT_FADE_DURATION) {
            this.invertTimer = 0;
            this.invertTrigger = false;
            this.invert(false);
          } else if (this.invertTimer) {
            this.invertTimer += deltaTime;
          } else {
            const actualDistance =
                this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));
  
            if (actualDistance > 0) {
              this.invertTrigger =
                  !(actualDistance % this.config.INVERT_DISTANCE);
  
              if (this.invertTrigger && this.invertTimer === 0) {
                this.invertTimer += deltaTime;
                this.invert(false);
              }
            }
          }
        }
      }
  
      if (this.playing || (!this.activated &&
          this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {
        this.tRex.update(deltaTime);
        this.scheduleNextUpdate();
      }
    },
  
    /**
     * Event handler.
     * @param {Event} e
     */
    handleEvent(e) {
      return (function(evtType, events) {
        switch (evtType) {
          case events.KEYDOWN:
          case events.TOUCHSTART:
          case events.POINTERDOWN:
            this.onKeyDown(e);
            break;
          case events.KEYUP:
          case events.TOUCHEND:
          case events.POINTERUP:
            this.onKeyUp(e);
            break;
          case events.GAMEPADCONNECTED:
            this.onGamepadConnected(e);
            break;
        }
      }.bind(this))(e.type, Runner.events);
    },
  
    /**
     * Initialize audio cues if activated by focus on the canvas element.
     * @param {Event} e
     */
    handleCanvasKeyPress(e) {
      if (!this.activated && !Runner.audioCues) {
        this.toggleSpeed();
        Runner.audioCues = true;
        this.generatedSoundFx.init();
        Runner.generatedSoundFx = this.generatedSoundFx;
        Runner.config.CLEAR_TIME *= 1.2;
      } else if (e.keyCode && Runner.keycodes.JUMP[e.keyCode]) {
        this.onKeyDown(e);
      }
    },
  
    /**
     * Prevent space key press from scrolling.
     * @param {Event} e
     */
    preventScrolling(e) {
      if (e.keyCode === 32) {
        e.preventDefault();
      }
    },
  
    /**
     * Toggle speed setting if toggle is shown.
     */
    toggleSpeed() {
      if (Runner.audioCues) {
        const speedChange = Runner.slowDown != this.slowSpeedCheckbox.checked;
  
        if (speedChange) {
          Runner.slowDown = this.slowSpeedCheckbox.checked;
          const updatedConfig =
              Runner.slowDown ? Runner.slowConfig : Runner.normalConfig;
  
          Runner.config = Object.assign(Runner.config, updatedConfig);
          this.currentSpeed = updatedConfig.SPEED;
          this.tRex.enableSlowConfig();
          this.horizon.adjustObstacleSpeed();
        }
        if (this.playing) {
          this.disableSpeedToggle(true);
        }
      }
    },
  
    /**
     * Show the speed toggle.
     * From focus event or when audio cues are activated.
     * @param {Event=} e
     */
    showSpeedToggle(e) {
      const isFocusEvent = e && e.type == 'focus';
      if (Runner.audioCues || isFocusEvent) {
        this.slowSpeedCheckboxLabel.classList.toggle(
            HIDDEN_CLASS, isFocusEvent ? false : !this.crashed);
      }
    },
  
    /**
     * Disable the speed toggle.
     * @param {boolean} disable
     */
    disableSpeedToggle(disable) {
      if (disable) {
        this.slowSpeedCheckbox.setAttribute('disabled', 'disabled');
      } else {
        this.slowSpeedCheckbox.removeAttribute('disabled');
      }
    },
  
    /**
     * Bind relevant key / mouse / touch listeners.
     */
    startListening() {
      // A11y keyboard / screen reader activation.
      this.containerEl.addEventListener(
          Runner.events.KEYDOWN, this.handleCanvasKeyPress.bind(this));
      if (!IS_MOBILE) {
        this.containerEl.addEventListener(
            Runner.events.FOCUS, this.showSpeedToggle.bind(this));
      }
      this.canvas.addEventListener(
          Runner.events.KEYDOWN, this.preventScrolling.bind(this));
      this.canvas.addEventListener(
          Runner.events.KEYUP, this.preventScrolling.bind(this));
  
      // Keys.
      document.addEventListener(Runner.events.KEYDOWN, this);
      document.addEventListener(Runner.events.KEYUP, this);
  
      // Touch / pointer.
      this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);
      document.addEventListener(Runner.events.POINTERDOWN, this);
      document.addEventListener(Runner.events.POINTERUP, this);
  
      if (this.isArcadeMode()) {
        // Gamepad
        window.addEventListener(Runner.events.GAMEPADCONNECTED, this);
      }
    },
  
    /**
     * Remove all listeners.
     */
    stopListening() {
      document.removeEventListener(Runner.events.KEYDOWN, this);
      document.removeEventListener(Runner.events.KEYUP, this);
  
      if (this.touchController) {
        this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);
        this.touchController.removeEventListener(Runner.events.TOUCHEND, this);
      }
  
      this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);
      document.removeEventListener(Runner.events.POINTERDOWN, this);
      document.removeEventListener(Runner.events.POINTERUP, this);
  
      if (this.isArcadeMode()) {
        window.removeEventListener(Runner.events.GAMEPADCONNECTED, this);
      }
    },
  
    /**
     * Process keydown.
     * @param {Event} e
     */
    onKeyDown(e) {
      // Prevent native page scrolling whilst tapping on mobile.
      if (IS_MOBILE && this.playing) {
        e.preventDefault();
      }
  
      if (this.isCanvasInView()) {
        // Allow toggling of speed toggle.
        if (Runner.keycodes.JUMP[e.keyCode] &&
            e.target == this.slowSpeedCheckbox) {
          return;
        }
  
        if (!this.crashed && !this.paused) {
          // For a11y, screen reader activation.
          const isMobileMouseInput = IS_MOBILE &&
                  e.type === Runner.events.POINTERDOWN &&
                  e.pointerType == 'mouse' && e.target == this.containerEl ||
              (IS_IOS && e.pointerType == 'touch' &&
               document.activeElement == this.containerEl);
  
          if (Runner.keycodes.JUMP[e.keyCode] ||
              e.type === Runner.events.TOUCHSTART || isMobileMouseInput ||
              (Runner.keycodes.DUCK[e.keyCode] && this.altGameModeActive)) {
            e.preventDefault();
            // Starting the game for the first time.
            if (!this.playing) {
              // Started by touch so create a touch controller.
              if (!this.touchController && e.type === Runner.events.TOUCHSTART) {
                this.createTouchController();
              }
  
              if (isMobileMouseInput) {
                this.handleCanvasKeyPress(e);
              }
              this.loadSounds();
              this.setPlayStatus(true);
              this.update();
              if (window.errorPageController) {
                errorPageController.trackEasterEgg();
              }
            }
            // Start jump.
            if (!this.tRex.jumping && !this.tRex.ducking) {
              if (Runner.audioCues) {
                this.generatedSoundFx.cancelFootSteps();
              } else {
                this.playSound(this.soundFx.BUTTON_PRESS);
              }
              this.tRex.startJump(this.currentSpeed);
            }
            // Ducking is disabled on alt game modes.
          } else if (
              !this.altGameModeActive && this.playing &&
              Runner.keycodes.DUCK[e.keyCode]) {
            e.preventDefault();
            if (this.tRex.jumping) {
              // Speed drop, activated only when jump key is not pressed.
              this.tRex.setSpeedDrop();
            } else if (!this.tRex.jumping && !this.tRex.ducking) {
              // Duck.
              this.tRex.setDuck(true);
            }
          }
        }
      }
    },
  
    /**
     * Process key up.
     * @param {Event} e
     */
    onKeyUp(e) {
      const keyCode = String(e.keyCode);
      const isjumpKey = Runner.keycodes.JUMP[keyCode] ||
          e.type === Runner.events.TOUCHEND || e.type === Runner.events.POINTERUP;
  
      if (this.isRunning() && isjumpKey) {
        this.tRex.endJump();
      } else if (Runner.keycodes.DUCK[keyCode]) {
        this.tRex.speedDrop = false;
        this.tRex.setDuck(false);
      } else if (this.crashed) {
        // Check that enough time has elapsed before allowing jump key to restart.
        const deltaTime = getTimeStamp() - this.time;
  
        if (this.isCanvasInView() &&
            (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||
            (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&
            Runner.keycodes.JUMP[keyCode]))) {
          this.handleGameOverClicks(e);
        }
      } else if (this.paused && isjumpKey) {
        // Reset the jump state
        this.tRex.reset();
        this.play();
      }
    },
  
    /**
     * Process gamepad connected event.
     * @param {Event} e
     */
    onGamepadConnected(e) {
      if (!this.pollingGamepads) {
        this.pollGamepadState();
      }
    },
  
    /**
     * rAF loop for gamepad polling.
     */
    pollGamepadState() {
      const gamepads = navigator.getGamepads();
      this.pollActiveGamepad(gamepads);
  
      this.pollingGamepads = true;
      requestAnimationFrame(this.pollGamepadState.bind(this));
    },
  
    /**
     * Polls for a gamepad with the jump button pressed. If one is found this
     * becomes the "active" gamepad and all others are ignored.
     * @param {!Array<Gamepad>} gamepads
     */
    pollForActiveGamepad(gamepads) {
      for (let i = 0; i < gamepads.length; ++i) {
        if (gamepads[i] && gamepads[i].buttons.length > 0 &&
            gamepads[i].buttons[0].pressed) {
          this.gamepadIndex = i;
          this.pollActiveGamepad(gamepads);
          return;
        }
      }
    },
  
    /**
     * Polls the chosen gamepad for button presses and generates KeyboardEvents
     * to integrate with the rest of the game logic.
     * @param {!Array<Gamepad>} gamepads
     */
    pollActiveGamepad(gamepads) {
      if (this.gamepadIndex === undefined) {
        this.pollForActiveGamepad(gamepads);
        return;
      }
  
      const gamepad = gamepads[this.gamepadIndex];
      if (!gamepad) {
        this.gamepadIndex = undefined;
        this.pollForActiveGamepad(gamepads);
        return;
      }
  
      // The gamepad specification defines the typical mapping of physical buttons
      // to button indicies: https://w3c.github.io/gamepad/#remapping
      this.pollGamepadButton(gamepad, 0, 38);  // Jump
      if (gamepad.buttons.length >= 2) {
        this.pollGamepadButton(gamepad, 1, 40);  // Duck
      }
      if (gamepad.buttons.length >= 10) {
        this.pollGamepadButton(gamepad, 9, 13);  // Restart
      }
  
      this.previousGamepad = gamepad;
    },
  
    /**
     * Generates a key event based on a gamepad button.
     * @param {!Gamepad} gamepad
     * @param {number} buttonIndex
     * @param {number} keyCode
     */
    pollGamepadButton(gamepad, buttonIndex, keyCode) {
      const state = gamepad.buttons[buttonIndex].pressed;
      let previousState = false;
      if (this.previousGamepad) {
        previousState = this.previousGamepad.buttons[buttonIndex].pressed;
      }
      // Generate key events on the rising and falling edge of a button press.
      if (state !== previousState) {
        const e = new KeyboardEvent(state ? Runner.events.KEYDOWN
                                        : Runner.events.KEYUP,
                                  { keyCode: keyCode });
        document.dispatchEvent(e);
      }
    },
  
    /**
     * Handle interactions on the game over screen state.
     * A user is able to tap the high score twice to reset it.
     * @param {Event} e
     */
    handleGameOverClicks(e) {
      if (e.target != this.slowSpeedCheckbox) {
        e.preventDefault();
        if (this.distanceMeter.hasClickedOnHighScore(e) && this.highestScore) {
          if (this.distanceMeter.isHighScoreFlashing()) {
            // Subsequent click, reset the high score.
            this.saveHighScore(0, true);
            this.distanceMeter.resetHighScore();
          } else {
            // First click, flash the high score.
            this.distanceMeter.startHighScoreFlashing();
          }
        } else {
          this.distanceMeter.cancelHighScoreFlashing();
          this.restart();
        }
      }
    },
  
    /**
     * Returns whether the event was a left click on canvas.
     * On Windows right click is registered as a click.
     * @param {Event} e
     * @return {boolean}
     */
    isLeftClickOnCanvas(e) {
      return e.button != null && e.button < 2 &&
          e.type === Runner.events.POINTERUP &&
          (e.target === this.canvas ||
           (IS_MOBILE && Runner.audioCues && e.target === this.containerEl));
    },
  
    /**
     * RequestAnimationFrame wrapper.
     */
    scheduleNextUpdate() {
      if (!this.updatePending) {
        this.updatePending = true;
        this.raqId = requestAnimationFrame(this.update.bind(this));
      }
    },
  
    /**
     * Whether the game is running.
     * @return {boolean}
     */
    isRunning() {
      return !!this.raqId;
    },
  
    /**
     * Set the initial high score as stored in the user's profile.
     * @param {number} highScore
     */
    initializeHighScore(highScore) {
      this.syncHighestScore = true;
      highScore = Math.ceil(highScore);
      if (highScore < this.highestScore) {
        if (window.errorPageController) {
          errorPageController.updateEasterEggHighScore(this.highestScore);
        }
        return;
      }
      this.highestScore = highScore;
      this.distanceMeter.setHighScore(this.highestScore);
    },
  
    /**
     * Sets the current high score and saves to the profile if available.
     * @param {number} distanceRan Total distance ran.
     * @param {boolean=} opt_resetScore Whether to reset the score.
     */
    saveHighScore(distanceRan, opt_resetScore) {
      this.highestScore = Math.ceil(distanceRan);
      this.distanceMeter.setHighScore(this.highestScore);
  
      // Store the new high score in the profile.
      if (this.syncHighestScore && window.errorPageController) {
        if (opt_resetScore) {
          errorPageController.resetEasterEggHighScore();
        } else {
          errorPageController.updateEasterEggHighScore(this.highestScore);
        }
      }
    },
  
    /**
     * Game over state.
     */
    gameOver() {
      this.playSound(this.soundFx.HIT);
      vibrate(200);
  
      this.stop();
      this.crashed = true;
      this.distanceMeter.achievement = false;
  
      this.tRex.update(100, Trex.status.CRASHED);
  
      // Game over panel.
      if (!this.gameOverPanel) {
        const origSpriteDef = IS_HIDPI ?
            Runner.spriteDefinitionByType.original.HDPI :
            Runner.spriteDefinitionByType.original.LDPI;
  
        if (this.canvas) {
          if (Runner.isAltGameModeEnabled) {
            this.gameOverPanel = new GameOverPanel(
                this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART,
                this.dimensions, origSpriteDef.ALT_GAME_END,
                this.altGameModeActive);
          } else {
            this.gameOverPanel = new GameOverPanel(
                this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART,
                this.dimensions);
          }
        }
      }
  
      this.gameOverPanel.draw(this.altGameModeActive, this.tRex);
  
      // Update the high score.
      if (this.distanceRan > this.highestScore) {
        this.saveHighScore(this.distanceRan);
      }
  
      // Reset the time clock.
      this.time = getTimeStamp();
  
      if (Runner.audioCues) {
        this.generatedSoundFx.stopAll();
        announcePhrase(
            getA11yString(A11Y_STRINGS.gameOver)
                .replace(
                    '$1',
                    this.distanceMeter.getActualDistance(this.distanceRan)
                        .toString()) +
            ' ' +
            getA11yString(A11Y_STRINGS.highScore)
                .replace(
                    '$1',
  
                    this.distanceMeter.getActualDistance(this.highestScore)
                        .toString()));
        this.containerEl.setAttribute(
            'title', getA11yString(A11Y_STRINGS.ariaLabel));
      }
      this.showSpeedToggle();
      this.disableSpeedToggle(false);
    },
  
    stop() {
      this.setPlayStatus(false);
      this.paused = true;
      cancelAnimationFrame(this.raqId);
      this.raqId = 0;
      this.generatedSoundFx.stopAll();
    },
  
    play() {
      if (!this.crashed) {
        this.setPlayStatus(true);
        this.paused = false;
        this.tRex.update(0, Trex.status.RUNNING);
        this.time = getTimeStamp();
        this.update();
        this.generatedSoundFx.background();
      }
    },
  
    restart() {
      if (!this.raqId) {
        this.playCount++;
        this.runningTime = 0;
        this.setPlayStatus(true);
        this.toggleSpeed();
        this.paused = false;
        this.crashed = false;
        this.distanceRan = 0;
        this.setSpeed(this.config.SPEED);
        this.time = getTimeStamp();
        this.containerEl.classList.remove(Runner.classes.CRASHED);
        this.clearCanvas();
        this.distanceMeter.reset();
        this.horizon.reset();
        this.tRex.reset();
        this.playSound(this.soundFx.BUTTON_PRESS);
        this.invert(true);
        this.flashTimer = null;
        this.update();
        this.gameOverPanel.reset();
        this.generatedSoundFx.background();
        this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump));
        announcePhrase(getA11yString(A11Y_STRINGS.started));
      }
    },
  
    setPlayStatus(isPlaying) {
      if (this.touchController) {
        this.touchController.classList.toggle(HIDDEN_CLASS, !isPlaying);
      }
      this.playing = isPlaying;
    },
  
    /**
     * Whether the game should go into arcade mode.
     * @return {boolean}
     */
    isArcadeMode() {
      // In RTL languages the title is wrapped with the left to right mark
      // control characters &#x202A; and &#x202C but are invisible.
      return IS_RTL ? document.title.indexOf(ARCADE_MODE_URL) == 1 :
                      document.title === ARCADE_MODE_URL;
    },
  
    /**
     * Hides offline messaging for a fullscreen game only experience.
     */
    setArcadeMode() {
      document.body.classList.add(Runner.classes.ARCADE_MODE);
      this.setArcadeModeContainerScale();
    },
  
    /**
     * Sets the scaling for arcade mode.
     */
    setArcadeModeContainerScale() {
      const windowHeight = window.innerHeight;
      const scaleHeight = windowHeight / this.dimensions.HEIGHT;
      const scaleWidth = window.innerWidth / this.dimensions.WIDTH;
      const scale = Math.max(1, Math.min(scaleHeight, scaleWidth));
      const scaledCanvasHeight = this.dimensions.HEIGHT * scale;
      // Positions the game container at 10% of the available vertical window
      // height minus the game container height.
      const translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -
          Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *
          Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *
          window.devicePixelRatio;
  
      const cssScale = IS_RTL ? -scale + ',' + scale : scale;
      this.containerEl.style.transform =
          'scale(' + cssScale + ') translateY(' + translateY + 'px)';
    },
  
    /**
     * Pause the game if the tab is not in focus.
     */
    onVisibilityChange(e) {
      if (document.hidden || document.webkitHidden || e.type === 'blur' ||
          document.visibilityState !== 'visible') {
        this.stop();
      } else if (!this.crashed) {
        this.tRex.reset();
        this.play();
      }
    },
  
    /**
     * Play a sound.
     * @param {AudioBuffer} soundBuffer
     */
    playSound(soundBuffer) {
      if (soundBuffer) {
        const sourceNode = this.audioContext.createBufferSource();
        sourceNode.buffer = soundBuffer;
        sourceNode.connect(this.audioContext.destination);
        sourceNode.start(0);
      }
    },
  
    /**
     * Inverts the current page / canvas colors.
     * @param {boolean} reset Whether to reset colors.
     */
    invert(reset) {
      const htmlEl = document.firstElementChild;
  
      if (reset) {
        htmlEl.classList.toggle(Runner.classes.INVERTED,
            false);
        this.invertTimer = 0;
        this.inverted = false;
      } else {
        this.inverted = htmlEl.classList.toggle(
            Runner.classes.INVERTED, this.invertTrigger);
      }
    },
  };
  
  
  /**
   * Updates the canvas size taking into
   * account the backing store pixel ratio and
   * the device pixel ratio.
   *
   * See article by Paul Lewis:
   * http://www.html5rocks.com/en/tutorials/canvas/hidpi/
   *
   * @param {HTMLCanvasElement} canvas
   * @param {number=} opt_width
   * @param {number=} opt_height
   * @return {boolean} Whether the canvas was scaled.
   */
  Runner.updateCanvasScaling = function(canvas, opt_width, opt_height) {
    const context =
        /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  
    // Query the various pixel ratios
    const devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;
    /** @suppress {missingProperties} */
    const backingStoreRatio =
        Math.floor(context.webkitBackingStorePixelRatio) || 1;
    const ratio = devicePixelRatio / backingStoreRatio;
  
    // Upscale the canvas if the two ratios don't match
    if (devicePixelRatio !== backingStoreRatio) {
      const oldWidth = opt_width || canvas.width;
      const oldHeight = opt_height || canvas.height;
  
      canvas.width = oldWidth * ratio;
      canvas.height = oldHeight * ratio;
  
      canvas.style.width = oldWidth + 'px';
      canvas.style.height = oldHeight + 'px';
  
      // Scale the context to counter the fact that we've manually scaled
      // our canvas element.
      context.scale(ratio, ratio);
      return true;
    } else if (devicePixelRatio === 1) {
      // Reset the canvas width / height. Fixes scaling bug when the page is
      // zoomed and the devicePixelRatio changes accordingly.
      canvas.style.width = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';
    }
    return false;
  };
  
  
  /**
   * Whether events are enabled.
   * @return {boolean}
   */
  Runner.isAltGameModeEnabled = function() {
    return loadTimeData && loadTimeData.valueExists('enableAltGameMode');
  };
  
  
  /**
   * Generated sound FX class for audio cues.
   * @constructor
   */
  function GeneratedSoundFx() {
    this.audioCues = false;
    this.context = null;
    this.panner = null;
  }
  
  GeneratedSoundFx.prototype = {
    init() {
      this.audioCues = true;
      if (!this.context) {
        // iOS only supports the webkit version.
        this.context = window.webkitAudioContext ? new webkitAudioContext() :
                                                   new AudioContext();
        if (IS_IOS) {
          this.context.onstatechange = (function() {
                                         if (this.context.state != 'running') {
                                           this.context.resume();
                                         }
                                       }).bind(this);
          this.context.resume();
        }
        this.panner = this.context.createStereoPanner ?
            this.context.createStereoPanner() :
            null;
      }
    },
  
    stopAll() {
      this.cancelFootSteps();
    },
  
    /**
     * Play oscillators at certain frequency and for a certain time.
     * @param {number} frequency
     * @param {number} startTime
     * @param {number} duration
     * @param {?number=} opt_vol
     * @param {number=} opt_pan
     */
    playNote(frequency, startTime, duration, opt_vol, opt_pan) {
      const osc1 = this.context.createOscillator();
      const osc2 = this.context.createOscillator();
      const volume = this.context.createGain();
  
      // Set oscillator wave type
      osc1.type = 'triangle';
      osc2.type = 'triangle';
      volume.gain.value = 0.1;
  
      // Set up node routing
      if (this.panner) {
        this.panner.pan.value = opt_pan || 0;
        osc1.connect(volume).connect(this.panner);
        osc2.connect(volume).connect(this.panner);
        this.panner.connect(this.context.destination);
      } else {
        osc1.connect(volume);
        osc2.connect(volume);
        volume.connect(this.context.destination);
      }
  
      // Detune oscillators for chorus effect
      osc1.frequency.value = frequency + 1;
      osc2.frequency.value = frequency - 2;
  
      // Fade out
      volume.gain.setValueAtTime(opt_vol || 0.01, startTime + duration - 0.05);
      volume.gain.linearRampToValueAtTime(0.00001, startTime + duration);
  
      // Start oscillators
      osc1.start(startTime);
      osc2.start(startTime);
      // Stop oscillators
      osc1.stop(startTime + duration);
      osc2.stop(startTime + duration);
    },
  
    background() {
      if (this.audioCues) {
        const now = this.context.currentTime;
        this.playNote(493.883, now, 0.116);
        this.playNote(659.255, now + 0.116, 0.232);
        this.loopFootSteps();
      }
    },
  
    loopFootSteps() {
      if (this.audioCues && !this.bgSoundIntervalId) {
        this.bgSoundIntervalId = setInterval(function() {
          this.playNote(73.42, this.context.currentTime, 0.05, 0.16);
          this.playNote(69.30, this.context.currentTime + 0.116, 0.116, 0.16);
        }.bind(this), 280);
      }
    },
  
    cancelFootSteps() {
      if (this.audioCues && this.bgSoundIntervalId) {
        clearInterval(this.bgSoundIntervalId);
        this.bgSoundIntervalId = null;
        this.playNote(103.83, this.context.currentTime, 0.232, 0.02);
        this.playNote(116.54, this.context.currentTime + 0.116, 0.232, 0.02);
      }
    },
  
    collect() {
      if (this.audioCues) {
        this.cancelFootSteps();
        const now = this.context.currentTime;
        this.playNote(830.61, now, 0.116);
        this.playNote(1318.51, now + 0.116, 0.232);
      }
    },
  
    jump() {
      if (this.audioCues) {
        const now = this.context.currentTime;
        this.playNote(659.25, now, 0.116, 0.3, -0.6);
        this.playNote(880, now + 0.116, 0.232, 0.3, -0.6);
      }
    },
  };
  
  
  /**
   * Speak a phrase using Speech Synthesis API for a11y.
   * @param {string} phrase Sentence to speak.
   */
  function speakPhrase(phrase) {
    if ('speechSynthesis' in window) {
      const msg = new SpeechSynthesisUtterance(phrase);
      const voices = window.speechSynthesis.getVoices();
      msg.text = phrase;
      speechSynthesis.speak(msg);
    }
  }
  
  
  /**
   * For screen readers make an announcement to the live region.
   * @param {string} phrase Sentence to speak.
   */
  function announcePhrase(phrase) {
    if (Runner.a11yStatusEl) {
      Runner.a11yStatusEl.textContent = '';
      Runner.a11yStatusEl.textContent = phrase;
    }
  }
  
  
  /**
   * Returns a string from loadTimeData data object.
   * @param {string} stringName
   * @return {string}
   */
  function getA11yString(stringName) {
    return loadTimeData && loadTimeData.valueExists(stringName) ?
        loadTimeData.getString(stringName) :
        '';
  }
  
  
  /**
   * Get random number.
   * @param {number} min
   * @param {number} max
   */
  function getRandomNum(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  
  
  /**
   * Vibrate on mobile devices.
   * @param {number} duration Duration of the vibration in milliseconds.
   */
  function vibrate(duration) {
    if (IS_MOBILE && window.navigator.vibrate) {
      window.navigator.vibrate(duration);
    }
  }
  
  
  /**
   * Create canvas element.
   * @param {Element} container Element to append canvas to.
   * @param {number} width
   * @param {number} height
   * @param {string=} opt_classname
   * @return {HTMLCanvasElement}
   */
  function createCanvas(container, width, height, opt_classname) {
    const canvas =
        /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
    canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +
        opt_classname : Runner.classes.CANVAS;
    canvas.width = width;
    canvas.height = height;
    container.appendChild(canvas);
  
    return canvas;
  }
  
  
  /**
   * Decodes the base 64 audio to ArrayBuffer used by Web Audio.
   * @param {string} base64String
   */
  function decodeBase64ToArrayBuffer(base64String) {
    const len = (base64String.length / 4) * 3;
    const str = atob(base64String);
    const arrayBuffer = new ArrayBuffer(len);
    const bytes = new Uint8Array(arrayBuffer);
  
    for (let i = 0; i < len; i++) {
      bytes[i] = str.charCodeAt(i);
    }
    return bytes.buffer;
  }
  
  
  /**
   * Return the current timestamp.
   * @return {number}
   */
  function getTimeStamp() {
    return IS_IOS ? new Date().getTime() : performance.now();
  }
  
  
  //******************************************************************************
  
  
  /**
   * Game over panel.
   * @param {!HTMLCanvasElement} canvas
   * @param {Object} textImgPos
   * @param {Object} restartImgPos
   * @param {!Object} dimensions Canvas dimensions.
   * @param {Object=} opt_altGameEndImgPos
   * @param {boolean=} opt_altGameActive
   * @constructor
   */
  function GameOverPanel(
      canvas, textImgPos, restartImgPos, dimensions, opt_altGameEndImgPos,
      opt_altGameActive) {
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    this.canvasDimensions = dimensions;
    this.textImgPos = textImgPos;
    this.restartImgPos = restartImgPos;
    this.altGameEndImgPos = opt_altGameEndImgPos;
    this.altGameModeActive = opt_altGameActive;
  
    // Retry animation.
    this.frameTimeStamp = 0;
    this.animTimer = 0;
    this.currentFrame = 0;
  
    this.gameOverRafId = null;
  
    this.flashTimer = 0;
    this.flashCounter = 0;
    this.originalText = true;
  }
  
  GameOverPanel.RESTART_ANIM_DURATION = 875;
  GameOverPanel.LOGO_PAUSE_DURATION = 875;
  GameOverPanel.FLASH_ITERATIONS = 5;
  
  /**
   * Animation frames spec.
   */
  GameOverPanel.animConfig = {
    frames: [0, 36, 72, 108, 144, 180, 216, 252],
    msPerFrame: GameOverPanel.RESTART_ANIM_DURATION / 8,
  };
  
  /**
   * Dimensions used in the panel.
   * @enum {number}
   */
  GameOverPanel.dimensions = {
    TEXT_X: 0,
    TEXT_Y: 13,
    TEXT_WIDTH: 191,
    TEXT_HEIGHT: 11,
    RESTART_WIDTH: 36,
    RESTART_HEIGHT: 32,
  };
  
  
  GameOverPanel.prototype = {
    /**
     * Update the panel dimensions.
     * @param {number} width New canvas width.
     * @param {number} opt_height Optional new canvas height.
     */
    updateDimensions(width, opt_height) {
      this.canvasDimensions.WIDTH = width;
      if (opt_height) {
        this.canvasDimensions.HEIGHT = opt_height;
      }
      this.currentFrame = GameOverPanel.animConfig.frames.length - 1;
    },
  
    drawGameOverText(dimensions, opt_useAltText) {
      const centerX = this.canvasDimensions.WIDTH / 2;
      let textSourceX = dimensions.TEXT_X;
      let textSourceY = dimensions.TEXT_Y;
      let textSourceWidth = dimensions.TEXT_WIDTH;
      let textSourceHeight = dimensions.TEXT_HEIGHT;
  
      const textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));
      const textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);
      const textTargetWidth = dimensions.TEXT_WIDTH;
      const textTargetHeight = dimensions.TEXT_HEIGHT;
  
      if (IS_HIDPI) {
        textSourceY *= 2;
        textSourceX *= 2;
        textSourceWidth *= 2;
        textSourceHeight *= 2;
      }
  
      if (!opt_useAltText) {
        textSourceX += this.textImgPos.x;
        textSourceY += this.textImgPos.y;
      }
  
      const spriteSource =
          opt_useAltText ? Runner.altCommonImageSprite : Runner.origImageSprite;
  
      this.canvasCtx.save();
  
      if (IS_RTL) {
        this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0);
        this.canvasCtx.scale(-1, 1);
      }
  
      // Game over text from sprite.
      this.canvasCtx.drawImage(
          spriteSource, textSourceX, textSourceY, textSourceWidth,
          textSourceHeight, textTargetX, textTargetY, textTargetWidth,
          textTargetHeight);
  
      this.canvasCtx.restore();
    },
  
    /**
     * Draw additional adornments for alternative game types.
     */
    drawAltGameElements(tRex) {
      // Additional adornments.
      if (this.altGameModeActive && Runner.spriteDefinition.ALT_GAME_END_CONFIG) {
        const altGameEndConfig = Runner.spriteDefinition.ALT_GAME_END_CONFIG;
  
        let altGameEndSourceWidth = altGameEndConfig.WIDTH;
        let altGameEndSourceHeight = altGameEndConfig.HEIGHT;
        const altGameEndTargetX = tRex.xPos + altGameEndConfig.X_OFFSET;
        const altGameEndTargetY = tRex.yPos + altGameEndConfig.Y_OFFSET;
  
        if (IS_HIDPI) {
          altGameEndSourceWidth *= 2;
          altGameEndSourceHeight *= 2;
        }
  
        this.canvasCtx.drawImage(
            Runner.altCommonImageSprite, this.altGameEndImgPos.x,
            this.altGameEndImgPos.y, altGameEndSourceWidth,
            altGameEndSourceHeight, altGameEndTargetX, altGameEndTargetY,
            altGameEndConfig.WIDTH, altGameEndConfig.HEIGHT);
      }
    },
  
    /**
     * Draw restart button.
     */
    drawRestartButton() {
      const dimensions = GameOverPanel.dimensions;
      let framePosX = GameOverPanel.animConfig.frames[this.currentFrame];
      let restartSourceWidth = dimensions.RESTART_WIDTH;
      let restartSourceHeight = dimensions.RESTART_HEIGHT;
      const restartTargetX =
          (this.canvasDimensions.WIDTH / 2) - (dimensions.RESTART_WIDTH / 2);
      const restartTargetY = this.canvasDimensions.HEIGHT / 2;
  
      if (IS_HIDPI) {
        restartSourceWidth *= 2;
        restartSourceHeight *= 2;
        framePosX *= 2;
      }
  
      this.canvasCtx.save();
  
      if (IS_RTL) {
        this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0);
        this.canvasCtx.scale(-1, 1);
      }
  
      this.canvasCtx.drawImage(
          Runner.origImageSprite, this.restartImgPos.x + framePosX,
          this.restartImgPos.y, restartSourceWidth, restartSourceHeight,
          restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,
          dimensions.RESTART_HEIGHT);
      this.canvasCtx.restore();
    },
  
  
    /**
     * Draw the panel.
     * @param {boolean} opt_altGameModeActive
     * @param {!Trex} opt_tRex
     */
    draw(opt_altGameModeActive, opt_tRex) {
      if (opt_altGameModeActive) {
        this.altGameModeActive = opt_altGameModeActive;
      }
  
      this.drawGameOverText(GameOverPanel.dimensions, false);
      this.drawRestartButton();
      this.drawAltGameElements(opt_tRex);
      this.update();
    },
  
    /**
     * Update animation frames.
     */
    update() {
      const now = getTimeStamp();
      const deltaTime = now - (this.frameTimeStamp || now);
  
      this.frameTimeStamp = now;
      this.animTimer += deltaTime;
      this.flashTimer += deltaTime;
  
      // Restart Button
      if (this.currentFrame == 0 &&
          this.animTimer > GameOverPanel.LOGO_PAUSE_DURATION) {
        this.animTimer = 0;
        this.currentFrame++;
        this.drawRestartButton();
      } else if (
          this.currentFrame > 0 &&
          this.currentFrame < GameOverPanel.animConfig.frames.length) {
        if (this.animTimer >= GameOverPanel.animConfig.msPerFrame) {
          this.currentFrame++;
          this.drawRestartButton();
        }
      } else if (
          !this.altGameModeActive &&
          this.currentFrame == GameOverPanel.animConfig.frames.length) {
        this.reset();
        return;
      }
  
      // Game over text
      if (this.altGameModeActive &&
          Runner.spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG) {
        const altTextConfig =
            Runner.spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG;
  
        if (this.flashCounter < GameOverPanel.FLASH_ITERATIONS &&
            this.flashTimer > altTextConfig.FLASH_DURATION) {
          this.flashTimer = 0;
          this.originalText = !this.originalText;
  
          this.clearGameOverTextBounds();
          if (this.originalText) {
            this.drawGameOverText(GameOverPanel.dimensions, false);
            this.flashCounter++;
          } else {
            this.drawGameOverText(altTextConfig, true);
          }
        } else if (this.flashCounter >= GameOverPanel.FLASH_ITERATIONS) {
          this.reset();
          return;
        }
      }
  
      this.gameOverRafId = requestAnimationFrame(this.update.bind(this));
    },
  
    /**
     * Clear game over text.
     */
    clearGameOverTextBounds() {
      this.canvasCtx.save();
  
      this.canvasCtx.clearRect(
          Math.round(
              this.canvasDimensions.WIDTH / 2 -
              (GameOverPanel.dimensions.TEXT_WIDTH / 2)),
          Math.round((this.canvasDimensions.HEIGHT - 25) / 3),
          GameOverPanel.dimensions.TEXT_WIDTH,
          GameOverPanel.dimensions.TEXT_HEIGHT + 4);
      this.canvasCtx.restore();
    },
  
    reset() {
      if (this.gameOverRafId) {
        cancelAnimationFrame(this.gameOverRafId);
        this.gameOverRafId = null;
      }
      this.animTimer = 0;
      this.frameTimeStamp = 0;
      this.currentFrame = 0;
      this.flashTimer = 0;
      this.flashCounter = 0;
      this.originalText = true;
    },
  };
  
  
  //******************************************************************************
  
  /**
   * Check for a collision.
   * @param {!Obstacle} obstacle
   * @param {!Trex} tRex T-rex object.
   * @param {CanvasRenderingContext2D=} opt_canvasCtx Optional canvas context for
   *    drawing collision boxes.
   * @return {Array<CollisionBox>|undefined}
   */
  function checkForCollision(obstacle, tRex, opt_canvasCtx) {
    const obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;
  
    // Adjustments are made to the bounding box as there is a 1 pixel white
    // border around the t-rex and obstacles.
    const tRexBox = new CollisionBox(
        tRex.xPos + 1,
        tRex.yPos + 1,
        tRex.config.WIDTH - 2,
        tRex.config.HEIGHT - 2);
  
    const obstacleBox = new CollisionBox(
        obstacle.xPos + 1,
        obstacle.yPos + 1,
        obstacle.typeConfig.width * obstacle.size - 2,
        obstacle.typeConfig.height - 2);
  
    // Debug outer box
    if (opt_canvasCtx) {
      drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);
    }
  
    // Simple outer bounds check.
    if (boxCompare(tRexBox, obstacleBox)) {
      const collisionBoxes = obstacle.collisionBoxes;
      let tRexCollisionBoxes = [];
  
      if (Runner.isAltGameModeEnabled()) {
        tRexCollisionBoxes = Runner.spriteDefinition.TREX.COLLISION_BOXES;
      } else {
        tRexCollisionBoxes = tRex.ducking ? Trex.collisionBoxes.DUCKING :
                                            Trex.collisionBoxes.RUNNING;
      }
  
      // Detailed axis aligned box check.
      for (let t = 0; t < tRexCollisionBoxes.length; t++) {
        for (let i = 0; i < collisionBoxes.length; i++) {
          // Adjust the box to actual positions.
          const adjTrexBox =
              createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);
          const adjObstacleBox =
              createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);
          const crashed = boxCompare(adjTrexBox, adjObstacleBox);
  
          // Draw boxes for debug.
          if (opt_canvasCtx) {
            drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);
          }
  
          if (crashed) {
            return [adjTrexBox, adjObstacleBox];
          }
        }
      }
    }
  }
  
  
  /**
   * Adjust the collision box.
   * @param {!CollisionBox} box The original box.
   * @param {!CollisionBox} adjustment Adjustment box.
   * @return {CollisionBox} The adjusted collision box object.
   */
  function createAdjustedCollisionBox(box, adjustment) {
    return new CollisionBox(
        box.x + adjustment.x,
        box.y + adjustment.y,
        box.width,
        box.height);
  }
  
  
  /**
   * Draw the collision boxes for debug.
   */
  function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {
    canvasCtx.save();
    canvasCtx.strokeStyle = '#f00';
    canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);
  
    canvasCtx.strokeStyle = '#0f0';
    canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,
        obstacleBox.width, obstacleBox.height);
    canvasCtx.restore();
  }
  
  
  /**
   * Compare two collision boxes for a collision.
   * @param {CollisionBox} tRexBox
   * @param {CollisionBox} obstacleBox
   * @return {boolean} Whether the boxes intersected.
   */
  function boxCompare(tRexBox, obstacleBox) {
    let crashed = false;
    const tRexBoxX = tRexBox.x;
    const tRexBoxY = tRexBox.y;
  
    const obstacleBoxX = obstacleBox.x;
    const obstacleBoxY = obstacleBox.y;
  
    // Axis-Aligned Bounding Box method.
    if (tRexBox.x < obstacleBoxX + obstacleBox.width &&
        tRexBox.x + tRexBox.width > obstacleBoxX &&
        tRexBox.y < obstacleBox.y + obstacleBox.height &&
        tRexBox.height + tRexBox.y > obstacleBox.y) {
      crashed = true;
    }
  
    return crashed;
  }
  
  
  //******************************************************************************
  
  /**
   * Collision box object.
   * @param {number} x X position.
   * @param {number} y Y Position.
   * @param {number} w Width.
   * @param {number} h Height.
   * @constructor
   */
  function CollisionBox(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h;
  }
  
  
  //******************************************************************************
  
  /**
   * Obstacle.
   * @param {CanvasRenderingContext2D} canvasCtx
   * @param {ObstacleType} type
   * @param {Object} spriteImgPos Obstacle position in sprite.
   * @param {Object} dimensions
   * @param {number} gapCoefficient Mutipler in determining the gap.
   * @param {number} speed
   * @param {number=} opt_xOffset
   * @param {boolean=} opt_isAltGameMode
   * @constructor
   */
  function Obstacle(
      canvasCtx, type, spriteImgPos, dimensions, gapCoefficient, speed,
      opt_xOffset, opt_isAltGameMode) {
    this.canvasCtx = canvasCtx;
    this.spritePos = spriteImgPos;
    this.typeConfig = type;
    this.gapCoefficient = Runner.slowDown ? gapCoefficient * 2 : gapCoefficient;
    this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);
    this.dimensions = dimensions;
    this.remove = false;
    this.xPos = dimensions.WIDTH + (opt_xOffset || 0);
    this.yPos = 0;
    this.width = 0;
    this.collisionBoxes = [];
    this.gap = 0;
    this.speedOffset = 0;
    this.altGameModeActive = opt_isAltGameMode;
    this.imageSprite = this.typeConfig.type == 'COLLECTABLE' ?
        Runner.altCommonImageSprite :
        this.altGameModeActive ? Runner.altGameImageSprite : Runner.imageSprite;
  
    // For animated obstacles.
    this.currentFrame = 0;
    this.timer = 0;
  
    this.init(speed);
  }
  
  /**
   * Coefficient for calculating the maximum gap.
   */
  Obstacle.MAX_GAP_COEFFICIENT = 1.5;
  
  /**
   * Maximum obstacle grouping count.
   */
  Obstacle.MAX_OBSTACLE_LENGTH = 3;
  
  
  Obstacle.prototype = {
    /**
     * Initialise the DOM for the obstacle.
     * @param {number} speed
     */
    init(speed) {
      this.cloneCollisionBoxes();
  
      // Only allow sizing if we're at the right speed.
      if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {
        this.size = 1;
      }
  
      this.width = this.typeConfig.width * this.size;
  
      // Check if obstacle can be positioned at various heights.
      if (Array.isArray(this.typeConfig.yPos)) {
        const yPosConfig =
            IS_MOBILE ? this.typeConfig.yPosMobile : this.typeConfig.yPos;
        this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];
      } else {
        this.yPos = this.typeConfig.yPos;
      }
  
      this.draw();
  
      // Make collision box adjustments,
      // Central box is adjusted to the size as one box.
      //      ____        ______        ________
      //    _|   |-|    _|     |-|    _|       |-|
      //   | |<->| |   | |<--->| |   | |<----->| |
      //   | | 1 | |   | |  2  | |   | |   3   | |
      //   |_|___|_|   |_|_____|_|   |_|_______|_|
      //
      if (this.size > 1) {
        this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -
            this.collisionBoxes[2].width;
        this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
      }
  
      // For obstacles that go at a different speed from the horizon.
      if (this.typeConfig.speedOffset) {
        this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :
                                                 -this.typeConfig.speedOffset;
      }
  
      this.gap = this.getGap(this.gapCoefficient, speed);
  
      // Increase gap for audio cues enabled.
      if (Runner.audioCues) {
        this.gap *= 2;
      }
    },
  
    /**
     * Draw and crop based on size.
     */
    draw() {
      let sourceWidth = this.typeConfig.width;
      let sourceHeight = this.typeConfig.height;
  
      if (IS_HIDPI) {
        sourceWidth = sourceWidth * 2;
        sourceHeight = sourceHeight * 2;
      }
  
      // X position in sprite.
      let sourceX =
          (sourceWidth * this.size) * (0.5 * (this.size - 1)) + this.spritePos.x;
  
      // Animation frames.
      if (this.currentFrame > 0) {
        sourceX += sourceWidth * this.currentFrame;
      }
  
      this.canvasCtx.drawImage(
          this.imageSprite, sourceX, this.spritePos.y, sourceWidth * this.size,
          sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size,
          this.typeConfig.height);
    },
  
    /**
     * Obstacle frame update.
     * @param {number} deltaTime
     * @param {number} speed
     */
    update(deltaTime, speed) {
      if (!this.remove) {
        if (this.typeConfig.speedOffset) {
          speed += this.speedOffset;
        }
        this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);
  
        // Update frame
        if (this.typeConfig.numFrames) {
          this.timer += deltaTime;
          if (this.timer >= this.typeConfig.frameRate) {
            this.currentFrame =
                this.currentFrame === this.typeConfig.numFrames - 1 ?
                0 :
                this.currentFrame + 1;
            this.timer = 0;
          }
        }
        this.draw();
  
        if (!this.isVisible()) {
          this.remove = true;
        }
      }
    },
  
    /**
     * Calculate a random gap size.
     * - Minimum gap gets wider as speed increses
     * @param {number} gapCoefficient
     * @param {number} speed
     * @return {number} The gap size.
     */
    getGap(gapCoefficient, speed) {
      const minGap = Math.round(
          this.width * speed + this.typeConfig.minGap * gapCoefficient);
      const maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);
      return getRandomNum(minGap, maxGap);
    },
  
    /**
     * Check if obstacle is visible.
     * @return {boolean} Whether the obstacle is in the game area.
     */
    isVisible() {
      return this.xPos + this.width > 0;
    },
  
    /**
     * Make a copy of the collision boxes, since these will change based on
     * obstacle type and size.
     */
    cloneCollisionBoxes() {
      const collisionBoxes = this.typeConfig.collisionBoxes;
  
      for (let i = collisionBoxes.length - 1; i >= 0; i--) {
        this.collisionBoxes[i] = new CollisionBox(
            collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width,
            collisionBoxes[i].height);
      }
    },
  };
  
  
  //******************************************************************************
  /**
   * T-rex game character.
   * @param {HTMLCanvasElement} canvas
   * @param {Object} spritePos Positioning within image sprite.
   * @constructor
   */
  function Trex(canvas, spritePos) {
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    this.spritePos = spritePos;
    this.xPos = 0;
    this.yPos = 0;
    this.xInitialPos = 0;
    // Position when on the ground.
    this.groundYPos = 0;
    this.currentFrame = 0;
    this.currentAnimFrames = [];
    this.blinkDelay = 0;
    this.blinkCount = 0;
    this.animStartTime = 0;
    this.timer = 0;
    this.msPerFrame = 1000 / FPS;
    this.config = Object.assign(Trex.config, Trex.normalJumpConfig);
    // Current status.
    this.status = Trex.status.WAITING;
    this.jumping = false;
    this.ducking = false;
    this.jumpVelocity = 0;
    this.reachedMinHeight = false;
    this.speedDrop = false;
    this.jumpCount = 0;
    this.jumpspotX = 0;
    this.altGameModeEnabled = false;
    this.flashing = false;
  
    this.init();
  }
  
  
  /**
   * T-rex player config.
   */
  Trex.config = {
    DROP_VELOCITY: -5,
    FLASH_OFF: 175,
    FLASH_ON: 100,
    HEIGHT: 47,
    HEIGHT_DUCK: 25,
    INTRO_DURATION: 1500,
    SPEED_DROP_COEFFICIENT: 3,
    SPRITE_WIDTH: 262,
    START_X_POS: 50,
    WIDTH: 44,
    WIDTH_DUCK: 59,
  };
  
  Trex.slowJumpConfig = {
    GRAVITY: 0.25,
    MAX_JUMP_HEIGHT: 50,
    MIN_JUMP_HEIGHT: 45,
    INITIAL_JUMP_VELOCITY: -20,
  };
  
  Trex.normalJumpConfig = {
    GRAVITY: 0.6,
    MAX_JUMP_HEIGHT: 30,
    MIN_JUMP_HEIGHT: 30,
    INITIAL_JUMP_VELOCITY: -10,
  };
  
  /**
   * Used in collision detection.
   * @enum {Array<CollisionBox>}
   */
  Trex.collisionBoxes = {
    DUCKING: [new CollisionBox(1, 18, 55, 25)],
    RUNNING: [
      new CollisionBox(22, 0, 17, 16),
      new CollisionBox(1, 18, 30, 9),
      new CollisionBox(10, 35, 14, 8),
      new CollisionBox(1, 24, 29, 5),
      new CollisionBox(5, 30, 21, 4),
      new CollisionBox(9, 34, 15, 4),
    ],
  };
  
  
  /**
   * Animation states.
   * @enum {string}
   */
  Trex.status = {
    CRASHED: 'CRASHED',
    DUCKING: 'DUCKING',
    JUMPING: 'JUMPING',
    RUNNING: 'RUNNING',
    WAITING: 'WAITING',
  };
  
  /**
   * Blinking coefficient.
   * @const
   */
  Trex.BLINK_TIMING = 7000;
  
  
  /**
   * Animation config for different states.
   * @enum {Object}
   */
  Trex.animFrames = {
    WAITING: {
      frames: [44, 0],
      msPerFrame: 1000 / 3,
    },
    RUNNING: {
      frames: [88, 132],
      msPerFrame: 1000 / 12,
    },
    CRASHED: {
      frames: [220],
      msPerFrame: 1000 / 60,
    },
    JUMPING: {
      frames: [0],
      msPerFrame: 1000 / 60,
    },
    DUCKING: {
      frames: [264, 323],
      msPerFrame: 1000 / 8,
    },
  };
  
  
  Trex.prototype = {
    /**
     * T-rex player initaliser.
     * Sets the t-rex to blink at random intervals.
     */
    init() {
      this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
          Runner.config.BOTTOM_PAD;
      this.yPos = this.groundYPos;
      this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;
  
      this.draw(0, 0);
      this.update(0, Trex.status.WAITING);
    },
  
    /**
     * Assign the appropriate jump parameters based on the game speed.
     */
    enableSlowConfig: function() {
      const jumpConfig =
          Runner.slowDown ? Trex.slowJumpConfig : Trex.normalJumpConfig;
      Trex.config = Object.assign(Trex.config, jumpConfig);
  
      this.adjustAltGameConfigForSlowSpeed();
    },
  
    /**
     * Enables the alternative game. Redefines the dino config.
     * @param {Object} spritePos New positioning within image sprite.
     */
    enableAltGameMode: function(spritePos) {
      this.altGameModeEnabled = true;
      this.spritePos = spritePos;
      const spriteDefinition = Runner.spriteDefinition['TREX'];
  
      // Update animation frames.
      Trex.animFrames.RUNNING.frames =
          [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x];
      Trex.animFrames.CRASHED.frames = [spriteDefinition.CRASHED.x];
  
      if (typeof spriteDefinition.JUMPING.x == 'object') {
        Trex.animFrames.JUMPING.frames = spriteDefinition.JUMPING.x;
      } else {
        Trex.animFrames.JUMPING.frames = [spriteDefinition.JUMPING.x];
      }
  
      Trex.animFrames.DUCKING.frames =
          [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x];
  
      // Update Trex config
      Trex.config.GRAVITY = spriteDefinition.GRAVITY || Trex.config.GRAVITY;
      Trex.config.HEIGHT = spriteDefinition.RUNNING_1.h,
      Trex.config.INITIAL_JUMP_VELOCITY = spriteDefinition.INITIAL_JUMP_VELOCITY;
      Trex.config.MAX_JUMP_HEIGHT = spriteDefinition.MAX_JUMP_HEIGHT;
      Trex.config.MIN_JUMP_HEIGHT = spriteDefinition.MIN_JUMP_HEIGHT;
      Trex.config.WIDTH = spriteDefinition.RUNNING_1.w;
      Trex.config.WIDTH_JUMP = spriteDefinition.JUMPING.w;
      Trex.config.INVERT_JUMP = spriteDefinition.INVERT_JUMP;
  
      this.adjustAltGameConfigForSlowSpeed(spriteDefinition.GRAVITY);
      this.config = Trex.config;
  
      // Adjust bottom horizon placement.
      this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
          Runner.spriteDefinition['BOTTOM_PAD'];
      this.yPos = this.groundYPos;
      this.reset();
    },
  
    /**
     * Slow speeds adjustments for the alt game modes.
     * @param {number=} opt_gravityValue
     */
    adjustAltGameConfigForSlowSpeed: function(opt_gravityValue) {
      if (Runner.slowDown) {
        if (opt_gravityValue) {
          Trex.config.GRAVITY = opt_gravityValue / 1.5;
        }
        Trex.config.MIN_JUMP_HEIGHT *= 1.5;
        Trex.config.MAX_JUMP_HEIGHT *= 1.5;
        Trex.config.INITIAL_JUMP_VELOCITY =
            Trex.config.INITIAL_JUMP_VELOCITY * 1.5;
      }
    },
  
    /**
     * Setter whether dino is flashing.
     * @param {boolean} status
     */
    setFlashing: function(status) {
      this.flashing = status;
    },
  
    /**
     * Setter for the jump velocity.
     * The approriate drop velocity is also set.
     * @param {number} setting
     */
    setJumpVelocity(setting) {
      this.config.INITIAL_JUMP_VELOCITY = -setting;
      this.config.DROP_VELOCITY = -setting / 2;
    },
  
    /**
     * Set the animation status.
     * @param {!number} deltaTime
     * @param {Trex.status=} opt_status Optional status to switch to.
     */
    update(deltaTime, opt_status) {
      this.timer += deltaTime;
  
      // Update the status.
      if (opt_status) {
        this.status = opt_status;
        this.currentFrame = 0;
        this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;
        this.currentAnimFrames = Trex.animFrames[opt_status].frames;
  
        if (opt_status === Trex.status.WAITING) {
          this.animStartTime = getTimeStamp();
          this.setBlinkDelay();
        }
      }
      // Game intro animation, T-rex moves in from the left.
      if (this.playingIntro && this.xPos < this.config.START_X_POS) {
        this.xPos += Math.round((this.config.START_X_POS /
            this.config.INTRO_DURATION) * deltaTime);
        this.xInitialPos = this.xPos;
      }
  
      if (this.status === Trex.status.WAITING) {
        this.blink(getTimeStamp());
      } else {
        this.draw(this.currentAnimFrames[this.currentFrame], 0);
      }
  
      // Update the frame position.
      if (!this.flashing && this.timer >= this.msPerFrame) {
        this.currentFrame = this.currentFrame ==
            this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;
        this.timer = 0;
      }
  
      if (!this.altGameModeEnabled) {
        // Speed drop becomes duck if the down key is still being pressed.
        if (this.speedDrop && this.yPos === this.groundYPos) {
          this.speedDrop = false;
          this.setDuck(true);
        }
      }
    },
  
    /**
     * Draw the t-rex to a particular position.
     * @param {number} x
     * @param {number} y
     */
    draw(x, y) {
      let sourceX = x;
      let sourceY = y;
      let sourceWidth = this.ducking && this.status !== Trex.status.CRASHED ?
          this.config.WIDTH_DUCK :
          this.config.WIDTH;
      let sourceHeight = this.config.HEIGHT;
      const outputHeight = sourceHeight;
  
      let jumpOffset = Runner.spriteDefinition.TREX.JUMPING.xOffset;
  
      // Width of sprite changes on jump.
      if (this.altGameModeEnabled && this.jumping &&
          this.status !== Trex.status.CRASHED) {
        sourceWidth = this.config.WIDTH_JUMP;
      }
  
      if (IS_HIDPI) {
        sourceX *= 2;
        sourceY *= 2;
        sourceWidth *= 2;
        sourceHeight *= 2;
        jumpOffset *= 2;
      }
  
      // Adjustments for sprite sheet position.
      sourceX += this.spritePos.x;
      sourceY += this.spritePos.y;
  
      // Flashing.
      if (this.flashing) {
        if (this.timer < this.config.FLASH_ON) {
          this.canvasCtx.globalAlpha = 0.5;
        } else if (this.timer > this.config.FLASH_OFF) {
          this.timer = 0;
        }
      }
  
      // Ducking.
      if (!this.altGameModeEnabled && this.ducking &&
          this.status !== Trex.status.CRASHED) {
        this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
            sourceWidth, sourceHeight,
            this.xPos, this.yPos,
            this.config.WIDTH_DUCK, outputHeight);
      } else if (
          this.altGameModeEnabled && this.jumping &&
          this.status !== Trex.status.CRASHED) {
        // Jumping with adjustments.
        this.canvasCtx.drawImage(
            Runner.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight,
            this.xPos - jumpOffset, this.yPos, this.config.WIDTH_JUMP,
            outputHeight);
      } else {
        // Crashed whilst ducking. Trex is standing up so needs adjustment.
        if (this.ducking && this.status === Trex.status.CRASHED) {
          this.xPos++;
        }
        // Standing / running
        this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
            sourceWidth, sourceHeight,
            this.xPos, this.yPos,
            this.config.WIDTH, outputHeight);
      }
      this.canvasCtx.globalAlpha = 1;
    },
  
    /**
     * Sets a random time for the blink to happen.
     */
    setBlinkDelay() {
      this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);
    },
  
    /**
     * Make t-rex blink at random intervals.
     * @param {number} time Current time in milliseconds.
     */
    blink(time) {
      const deltaTime = time - this.animStartTime;
  
      if (deltaTime >= this.blinkDelay) {
        this.draw(this.currentAnimFrames[this.currentFrame], 0);
  
        if (this.currentFrame === 1) {
          // Set new random delay to blink.
          this.setBlinkDelay();
          this.animStartTime = time;
          this.blinkCount++;
        }
      }
    },
  
    /**
     * Initialise a jump.
     * @param {number} speed
     */
    startJump(speed) {
      if (!this.jumping) {
        this.update(0, Trex.status.JUMPING);
        // Tweak the jump velocity based on the speed.
        this.jumpVelocity = this.config.INITIAL_JUMP_VELOCITY - (speed / 10);
        this.jumping = true;
        this.reachedMinHeight = false;
        this.speedDrop = false;
  
        if (this.config.INVERT_JUMP) {
          this.minJumpHeight = this.groundYPos + this.config.MIN_JUMP_HEIGHT;
        }
      }
    },
  
    /**
     * Jump is complete, falling down.
     */
    endJump() {
      if (this.reachedMinHeight &&
          this.jumpVelocity < this.config.DROP_VELOCITY) {
        this.jumpVelocity = this.config.DROP_VELOCITY;
      }
    },
  
    /**
     * Update frame for a jump.
     * @param {number} deltaTime
     */
    updateJump(deltaTime) {
      const msPerFrame = Trex.animFrames[this.status].msPerFrame;
      const framesElapsed = deltaTime / msPerFrame;
  
      // Speed drop makes Trex fall faster.
      if (this.speedDrop) {
        this.yPos += Math.round(this.jumpVelocity *
            this.config.SPEED_DROP_COEFFICIENT * framesElapsed);
      } else if (this.config.INVERT_JUMP) {
        this.yPos -= Math.round(this.jumpVelocity * framesElapsed);
      } else {
        this.yPos += Math.round(this.jumpVelocity * framesElapsed);
      }
  
      this.jumpVelocity += this.config.GRAVITY * framesElapsed;
  
      // Minimum height has been reached.
      if (this.config.INVERT_JUMP && (this.yPos > this.minJumpHeight) ||
          !this.config.INVERT_JUMP && (this.yPos < this.minJumpHeight) ||
          this.speedDrop) {
        this.reachedMinHeight = true;
      }
  
      // Reached max height.
      if (this.config.INVERT_JUMP && (this.yPos > -this.config.MAX_JUMP_HEIGHT) ||
          !this.config.INVERT_JUMP && (this.yPos < this.config.MAX_JUMP_HEIGHT) ||
          this.speedDrop) {
        this.endJump();
      }
  
      // Back down at ground level. Jump completed.
      if ((this.config.INVERT_JUMP && this.yPos) < this.groundYPos ||
          (!this.config.INVERT_JUMP && this.yPos) > this.groundYPos) {
        this.reset();
        this.jumpCount++;
  
        if (Runner.audioCues) {
          Runner.generatedSoundFx.loopFootSteps();
        }
      }
    },
  
    /**
     * Set the speed drop. Immediately cancels the current jump.
     */
    setSpeedDrop() {
      this.speedDrop = true;
      this.jumpVelocity = 1;
    },
  
    /**
     * @param {boolean} isDucking
     */
    setDuck(isDucking) {
      if (isDucking && this.status !== Trex.status.DUCKING) {
        this.update(0, Trex.status.DUCKING);
        this.ducking = true;
      } else if (this.status === Trex.status.DUCKING) {
        this.update(0, Trex.status.RUNNING);
        this.ducking = false;
      }
    },
  
    /**
     * Reset the t-rex to running at start of game.
     */
    reset() {
      this.xPos = this.xInitialPos;
      this.yPos = this.groundYPos;
      this.jumpVelocity = 0;
      this.jumping = false;
      this.ducking = false;
      this.update(0, Trex.status.RUNNING);
      this.midair = false;
      this.speedDrop = false;
      this.jumpCount = 0;
    },
  };
  
  
  //******************************************************************************
  
  /**
   * Handles displaying the distance meter.
   * @param {!HTMLCanvasElement} canvas
   * @param {Object} spritePos Image position in sprite.
   * @param {number} canvasWidth
   * @constructor
   */
  function DistanceMeter(canvas, spritePos, canvasWidth) {
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    this.image = Runner.imageSprite;
    this.spritePos = spritePos;
    this.x = 0;
    this.y = 5;
  
    this.currentDistance = 0;
    this.maxScore = 0;
    this.highScore = '0';
    this.container = null;
  
    this.digits = [];
    this.achievement = false;
    this.defaultString = '';
    this.flashTimer = 0;
    this.flashIterations = 0;
    this.invertTrigger = false;
    this.flashingRafId = null;
    this.highScoreBounds = {};
    this.highScoreFlashing = false;
  
    this.config = DistanceMeter.config;
    this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;
    this.canvasWidth = canvasWidth;
    this.init(canvasWidth);
  }
  
  
  /**
   * @enum {number}
   */
  DistanceMeter.dimensions = {
    WIDTH: 10,
    HEIGHT: 13,
    DEST_WIDTH: 11,
  };
  
  
  /**
   * Y positioning of the digits in the sprite sheet.
   * X position is always 0.
   * @type {Array<number>}
   */
  DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];
  
  
  /**
   * Distance meter config.
   * @enum {number}
   */
  DistanceMeter.config = {
    // Number of digits.
    MAX_DISTANCE_UNITS: 5,
  
    // Distance that causes achievement animation.
    ACHIEVEMENT_DISTANCE: 100,
  
    // Used for conversion from pixel distance to a scaled unit.
    COEFFICIENT: 0.025,
  
    // Flash duration in milliseconds.
    FLASH_DURATION: 1000 / 4,
  
    // Flash iterations for achievement animation.
    FLASH_ITERATIONS: 3,
  
    // Padding around the high score hit area.
    HIGH_SCORE_HIT_AREA_PADDING: 4,
  };
  
  
  DistanceMeter.prototype = {
    /**
     * Initialise the distance meter to '00000'.
     * @param {number} width Canvas width in px.
     */
    init(width) {
      let maxDistanceStr = '';
  
      this.calcXPos(width);
      this.maxScore = this.maxScoreUnits;
      for (let i = 0; i < this.maxScoreUnits; i++) {
        this.draw(i, 0);
        this.defaultString += '0';
        maxDistanceStr += '9';
      }
  
      this.maxScore = parseInt(maxDistanceStr, 10);
    },
  
    /**
     * Calculate the xPos in the canvas.
     * @param {number} canvasWidth
     */
    calcXPos(canvasWidth) {
      this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *
          (this.maxScoreUnits + 1));
    },
  
    /**
     * Draw a digit to canvas.
     * @param {number} digitPos Position of the digit.
     * @param {number} value Digit value 0-9.
     * @param {boolean=} opt_highScore Whether drawing the high score.
     */
    draw(digitPos, value, opt_highScore) {
      let sourceWidth = DistanceMeter.dimensions.WIDTH;
      let sourceHeight = DistanceMeter.dimensions.HEIGHT;
      let sourceX = DistanceMeter.dimensions.WIDTH * value;
      let sourceY = 0;
  
      const targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;
      const targetY = this.y;
      const targetWidth = DistanceMeter.dimensions.WIDTH;
      const targetHeight = DistanceMeter.dimensions.HEIGHT;
  
      // For high DPI we 2x source values.
      if (IS_HIDPI) {
        sourceWidth *= 2;
        sourceHeight *= 2;
        sourceX *= 2;
      }
  
      sourceX += this.spritePos.x;
      sourceY += this.spritePos.y;
  
      this.canvasCtx.save();
  
      if (IS_RTL) {
        if (opt_highScore) {
          this.canvasCtx.translate(
              this.canvasWidth -
                  (DistanceMeter.dimensions.WIDTH * (this.maxScoreUnits + 3)),
              this.y);
        } else {
          this.canvasCtx.translate(
              this.canvasWidth - DistanceMeter.dimensions.WIDTH, this.y);
        }
        this.canvasCtx.scale(-1, 1);
      } else {
        const highScoreX =
            this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH;
        if (opt_highScore) {
          this.canvasCtx.translate(highScoreX, this.y);
        } else {
          this.canvasCtx.translate(this.x, this.y);
        }
      }
  
      this.canvasCtx.drawImage(
          this.image,
          sourceX,
          sourceY,
          sourceWidth,
          sourceHeight,
          targetX,
          targetY,
          targetWidth,
          targetHeight,
      );
  
      this.canvasCtx.restore();
    },
  
    /**
     * Covert pixel distance to a 'real' distance.
     * @param {number} distance Pixel distance ran.
     * @return {number} The 'real' distance ran.
     */
    getActualDistance(distance) {
      return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;
    },
  
    /**
     * Update the distance meter.
     * @param {number} distance
     * @param {number} deltaTime
     * @return {boolean} Whether the acheivement sound fx should be played.
     */
    update(deltaTime, distance) {
      let paint = true;
      let playSound = false;
  
      if (!this.achievement) {
        distance = this.getActualDistance(distance);
        // Score has gone beyond the initial digit count.
        if (distance > this.maxScore && this.maxScoreUnits ==
          this.config.MAX_DISTANCE_UNITS) {
          this.maxScoreUnits++;
          this.maxScore = parseInt(this.maxScore + '9', 10);
        } else {
          this.distance = 0;
        }
  
        if (distance > 0) {
          // Achievement unlocked.
          if (distance % this.config.ACHIEVEMENT_DISTANCE === 0) {
            // Flash score and play sound.
            this.achievement = true;
            this.flashTimer = 0;
            playSound = true;
          }
  
          // Create a string representation of the distance with leading 0.
          const distanceStr = (this.defaultString +
              distance).substr(-this.maxScoreUnits);
          this.digits = distanceStr.split('');
        } else {
          this.digits = this.defaultString.split('');
        }
      } else {
        // Control flashing of the score on reaching acheivement.
        if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
          this.flashTimer += deltaTime;
  
          if (this.flashTimer < this.config.FLASH_DURATION) {
            paint = false;
          } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
            this.flashTimer = 0;
            this.flashIterations++;
          }
        } else {
          this.achievement = false;
          this.flashIterations = 0;
          this.flashTimer = 0;
        }
      }
  
      // Draw the digits if not flashing.
      if (paint) {
        for (let i = this.digits.length - 1; i >= 0; i--) {
          this.draw(i, parseInt(this.digits[i], 10));
        }
      }
  
      this.drawHighScore();
      return playSound;
    },
  
    /**
     * Draw the high score.
     */
    drawHighScore() {
      if (parseInt(this.highScore, 10) > 0) {
        this.canvasCtx.save();
        this.canvasCtx.globalAlpha = .8;
        for (let i = this.highScore.length - 1; i >= 0; i--) {
          this.draw(i, parseInt(this.highScore[i], 10), true);
        }
        this.canvasCtx.restore();
      }
    },
  
    /**
     * Set the highscore as a array string.
     * Position of char in the sprite: H - 10, I - 11.
     * @param {number} distance Distance ran in pixels.
     */
    setHighScore(distance) {
      distance = this.getActualDistance(distance);
      const highScoreStr = (this.defaultString +
          distance).substr(-this.maxScoreUnits);
  
      this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));
    },
  
  
    /**
     * Whether a clicked is in the high score area.
     * @param {Event} e Event object.
     * @return {boolean} Whether the click was in the high score bounds.
     */
    hasClickedOnHighScore(e) {
      let x = 0;
      let y = 0;
  
      if (e.touches) {
        // Bounds for touch differ from pointer.
        const canvasBounds = this.canvas.getBoundingClientRect();
        x = e.touches[0].clientX - canvasBounds.left;
        y = e.touches[0].clientY - canvasBounds.top;
      } else {
        x = e.offsetX;
        y = e.offsetY;
      }
  
      this.highScoreBounds = this.getHighScoreBounds();
      return x >= this.highScoreBounds.x && x <=
          this.highScoreBounds.x + this.highScoreBounds.width &&
          y >= this.highScoreBounds.y && y <=
          this.highScoreBounds.y + this.highScoreBounds.height;
    },
  
    /**
     * Get the bounding box for the high score.
     * @return {Object} Object with x, y, width and height properties.
     */
    getHighScoreBounds() {
      return {
        x: (this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH) -
            DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
        y: this.y,
        width: DistanceMeter.dimensions.WIDTH * (this.highScore.length + 1) +
            DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
        height: DistanceMeter.dimensions.HEIGHT +
            (DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING * 2),
      };
    },
  
    /**
     * Animate flashing the high score to indicate ready for resetting.
     * The flashing stops following this.config.FLASH_ITERATIONS x 2 flashes.
     */
    flashHighScore() {
      const now = getTimeStamp();
      const deltaTime = now - (this.frameTimeStamp || now);
      let paint = true;
      this.frameTimeStamp = now;
  
      // Reached the max number of flashes.
      if (this.flashIterations > this.config.FLASH_ITERATIONS * 2) {
        this.cancelHighScoreFlashing();
        return;
      }
  
      this.flashTimer += deltaTime;
  
      if (this.flashTimer < this.config.FLASH_DURATION) {
        paint = false;
      } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
        this.flashTimer = 0;
        this.flashIterations++;
      }
  
      if (paint) {
        this.drawHighScore();
      } else {
        this.clearHighScoreBounds();
      }
      // Frame update.
      this.flashingRafId =
          requestAnimationFrame(this.flashHighScore.bind(this));
    },
  
    /**
     * Draw empty rectangle over high score.
     */
    clearHighScoreBounds() {
      this.canvasCtx.save();
      this.canvasCtx.fillStyle = '#fff';
      this.canvasCtx.rect(this.highScoreBounds.x, this.highScoreBounds.y,
          this.highScoreBounds.width, this.highScoreBounds.height);
      this.canvasCtx.fill();
      this.canvasCtx.restore();
    },
  
    /**
     * Starts the flashing of the high score.
     */
    startHighScoreFlashing() {
      this.highScoreFlashing = true;
      this.flashHighScore();
    },
  
    /**
     * Whether high score is flashing.
     * @return {boolean}
     */
    isHighScoreFlashing() {
      return this.highScoreFlashing;
    },
  
    /**
     * Stop flashing the high score.
     */
    cancelHighScoreFlashing() {
      if (this.flashingRafId) {
        cancelAnimationFrame(this.flashingRafId);
      }
      this.flashIterations = 0;
      this.flashTimer = 0;
      this.highScoreFlashing = false;
      this.clearHighScoreBounds();
      this.drawHighScore();
    },
  
    /**
     * Clear the high score.
     */
    resetHighScore() {
      this.setHighScore(0);
      this.cancelHighScoreFlashing();
    },
  
    /**
     * Reset the distance meter back to '00000'.
     */
    reset() {
      this.update(0, 0);
      this.achievement = false;
    },
  };
  
  
  //******************************************************************************
  
  /**
   * Cloud background item.
   * Similar to an obstacle object but without collision boxes.
   * @param {HTMLCanvasElement} canvas Canvas element.
   * @param {Object} spritePos Position of image in sprite.
   * @param {number} containerWidth
   * @constructor
   */
  function Cloud(canvas, spritePos, containerWidth) {
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
    this.spritePos = spritePos;
    this.containerWidth = containerWidth;
    this.xPos = containerWidth;
    this.yPos = 0;
    this.remove = false;
    this.gap =
        getRandomNum(Cloud.config.MIN_CLOUD_GAP, Cloud.config.MAX_CLOUD_GAP);
  
    this.init();
  }
  
  
  /**
   * Cloud object config.
   * @enum {number}
   */
  Cloud.config = {
    HEIGHT: 14,
    MAX_CLOUD_GAP: 400,
    MAX_SKY_LEVEL: 30,
    MIN_CLOUD_GAP: 100,
    MIN_SKY_LEVEL: 71,
    WIDTH: 46,
  };
  
  
  Cloud.prototype = {
    /**
     * Initialise the cloud. Sets the Cloud height.
     */
    init() {
      this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,
          Cloud.config.MIN_SKY_LEVEL);
      this.draw();
    },
  
    /**
     * Draw the cloud.
     */
    draw() {
      this.canvasCtx.save();
      let sourceWidth = Cloud.config.WIDTH;
      let sourceHeight = Cloud.config.HEIGHT;
      const outputWidth = sourceWidth;
      const outputHeight = sourceHeight;
      if (IS_HIDPI) {
        sourceWidth = sourceWidth * 2;
        sourceHeight = sourceHeight * 2;
      }
  
      this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,
          this.spritePos.y,
          sourceWidth, sourceHeight,
          this.xPos, this.yPos,
          outputWidth, outputHeight);
  
      this.canvasCtx.restore();
    },
  
    /**
     * Update the cloud position.
     * @param {number} speed
     */
    update(speed) {
      if (!this.remove) {
        this.xPos -= Math.ceil(speed);
        this.draw();
  
        // Mark as removeable if no longer in the canvas.
        if (!this.isVisible()) {
          this.remove = true;
        }
      }
    },
  
    /**
     * Check if the cloud is visible on the stage.
     * @return {boolean}
     */
    isVisible() {
      return this.xPos + Cloud.config.WIDTH > 0;
    },
  };
  
  
  /**
   * Background item.
   * Similar to cloud, without random y position.
   * @param {HTMLCanvasElement} canvas Canvas element.
   * @param {Object} spritePos Position of image in sprite.
   * @param {number} containerWidth
   * @param {string} type Element type.
   * @constructor
   */
  function BackgroundEl(canvas, spritePos, containerWidth, type) {
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
    this.spritePos = spritePos;
    this.containerWidth = containerWidth;
    this.xPos = containerWidth;
    this.yPos = 0;
    this.remove = false;
    this.type = type;
    this.gap =
        getRandomNum(BackgroundEl.config.MIN_GAP, BackgroundEl.config.MAX_GAP);
    this.animTimer = 0;
    this.switchFrames = false;
  
    this.spriteConfig = {};
    this.init();
  }
  
  /**
   * Background element object config.
   * Real values assigned when game type changes.
   * @enum {number}
   */
  BackgroundEl.config = {
    MAX_BG_ELS: 0,
    MAX_GAP: 0,
    MIN_GAP: 0,
    POS: 0,
    SPEED: 0,
    Y_POS: 0,
    MS_PER_FRAME: 0,  // only needed when BACKGROUND_EL.FIXED is true
  };
  
  
  BackgroundEl.prototype = {
    /**
     * Initialise the element setting the y position.
     */
    init() {
      this.spriteConfig = Runner.spriteDefinition.BACKGROUND_EL[this.type];
      if (this.spriteConfig.FIXED) {
        this.xPos = this.spriteConfig.FIXED_X_POS;
      }
      this.yPos = BackgroundEl.config.Y_POS - this.spriteConfig.HEIGHT +
          this.spriteConfig.OFFSET;
      this.draw();
    },
  
    /**
     * Draw the element.
     */
    draw() {
      this.canvasCtx.save();
      let sourceWidth = this.spriteConfig.WIDTH;
      let sourceHeight = this.spriteConfig.HEIGHT;
      let sourceX = this.spriteConfig.X_POS;
      const outputWidth = sourceWidth;
      const outputHeight = sourceHeight;
  
      if (IS_HIDPI) {
        sourceWidth *= 2;
        sourceHeight *= 2;
        sourceX *= 2;
      }
  
      this.canvasCtx.drawImage(
          Runner.imageSprite, sourceX, this.spritePos.y, sourceWidth,
          sourceHeight, this.xPos, this.yPos, outputWidth, outputHeight);
  
      this.canvasCtx.restore();
    },
  
    /**
     * Update the background element position.
     * @param {number} speed
     */
    update(speed) {
      if (!this.remove) {
        if (this.spriteConfig.FIXED) {
          this.animTimer += speed;
          if (this.animTimer > BackgroundEl.config.MS_PER_FRAME) {
            this.animTimer = 0;
            this.switchFrames = !this.switchFrames;
          }
  
          if (this.spriteConfig.FIXED_Y_POS_1 &&
              this.spriteConfig.FIXED_Y_POS_2) {
            this.yPos = this.switchFrames ? this.spriteConfig.FIXED_Y_POS_1 :
                                            this.spriteConfig.FIXED_Y_POS_2;
          }
        } else {
          // Fixed speed, regardless of actual game speed.
          this.xPos -= BackgroundEl.config.SPEED;
        }
        this.draw();
  
        // Mark as removable if no longer in the canvas.
        if (!this.isVisible()) {
          this.remove = true;
        }
      }
    },
  
    /**
     * Check if the element is visible on the stage.
     * @return {boolean}
     */
    isVisible() {
      return this.xPos + this.spriteConfig.WIDTH > 0;
    },
  };
  
  
  
  //******************************************************************************
  
  /**
   * Nightmode shows a moon and stars on the horizon.
   * @param {HTMLCanvasElement} canvas
   * @param {number} spritePos
   * @param {number} containerWidth
   * @constructor
   */
  function NightMode(canvas, spritePos, containerWidth) {
    this.spritePos = spritePos;
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    this.xPos = containerWidth - 50;
    this.yPos = 30;
    this.currentPhase = 0;
    this.opacity = 0;
    this.containerWidth = containerWidth;
    this.stars = [];
    this.drawStars = false;
    this.placeStars();
  }
  
  /**
   * @enum {number}
   */
  NightMode.config = {
    FADE_SPEED: 0.035,
    HEIGHT: 40,
    MOON_SPEED: 0.25,
    NUM_STARS: 2,
    STAR_SIZE: 9,
    STAR_SPEED: 0.3,
    STAR_MAX_Y: 70,
    WIDTH: 20,
  };
  
  NightMode.phases = [140, 120, 100, 60, 40, 20, 0];
  
  NightMode.prototype = {
    /**
     * Update moving moon, changing phases.
     * @param {boolean} activated Whether night mode is activated.
     */
    update(activated) {
      // Moon phase.
      if (activated && this.opacity === 0) {
        this.currentPhase++;
  
        if (this.currentPhase >= NightMode.phases.length) {
          this.currentPhase = 0;
        }
      }
  
      // Fade in / out.
      if (activated && (this.opacity < 1 || this.opacity === 0)) {
        this.opacity += NightMode.config.FADE_SPEED;
      } else if (this.opacity > 0) {
        this.opacity -= NightMode.config.FADE_SPEED;
      }
  
      // Set moon positioning.
      if (this.opacity > 0) {
        this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);
  
        // Update stars.
        if (this.drawStars) {
          for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
            this.stars[i].x =
                this.updateXPos(this.stars[i].x, NightMode.config.STAR_SPEED);
          }
        }
        this.draw();
      } else {
        this.opacity = 0;
        this.placeStars();
      }
      this.drawStars = true;
    },
  
    updateXPos(currentPos, speed) {
      if (currentPos < -NightMode.config.WIDTH) {
        currentPos = this.containerWidth;
      } else {
        currentPos -= speed;
      }
      return currentPos;
    },
  
    draw() {
      let moonSourceWidth = this.currentPhase === 3 ? NightMode.config.WIDTH * 2 :
                                                      NightMode.config.WIDTH;
      let moonSourceHeight = NightMode.config.HEIGHT;
      let moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];
      const moonOutputWidth = moonSourceWidth;
      let starSize = NightMode.config.STAR_SIZE;
      let starSourceX = Runner.spriteDefinitionByType.original.LDPI.STAR.x;
  
      if (IS_HIDPI) {
        moonSourceWidth *= 2;
        moonSourceHeight *= 2;
        moonSourceX = this.spritePos.x +
            (NightMode.phases[this.currentPhase] * 2);
        starSize *= 2;
        starSourceX = Runner.spriteDefinitionByType.original.HDPI.STAR.x;
      }
  
      this.canvasCtx.save();
      this.canvasCtx.globalAlpha = this.opacity;
  
      // Stars.
      if (this.drawStars) {
        for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
          this.canvasCtx.drawImage(
              Runner.origImageSprite, starSourceX, this.stars[i].sourceY,
              starSize, starSize, Math.round(this.stars[i].x), this.stars[i].y,
              NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);
        }
      }
  
      // Moon.
      this.canvasCtx.drawImage(
          Runner.origImageSprite, moonSourceX, this.spritePos.y, moonSourceWidth,
          moonSourceHeight, Math.round(this.xPos), this.yPos, moonOutputWidth,
          NightMode.config.HEIGHT);
  
      this.canvasCtx.globalAlpha = 1;
      this.canvasCtx.restore();
    },
  
    // Do star placement.
    placeStars() {
      const segmentSize = Math.round(this.containerWidth /
          NightMode.config.NUM_STARS);
  
      for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
        this.stars[i] = {};
        this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));
        this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);
  
        if (IS_HIDPI) {
          this.stars[i].sourceY =
              Runner.spriteDefinitionByType.original.HDPI.STAR.y +
              NightMode.config.STAR_SIZE * 2 * i;
        } else {
          this.stars[i].sourceY =
              Runner.spriteDefinitionByType.original.LDPI.STAR.y +
              NightMode.config.STAR_SIZE * i;
        }
      }
    },
  
    reset() {
      this.currentPhase = 0;
      this.opacity = 0;
      this.update(false);
    },
  
  };
  
  
  //******************************************************************************
  
  /**
   * Horizon Line.
   * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.
   * @param {HTMLCanvasElement} canvas
   * @param {Object} lineConfig Configuration object.
   * @constructor
   */
  function HorizonLine(canvas, lineConfig) {
    let sourceX = lineConfig.SOURCE_X;
    let sourceY = lineConfig.SOURCE_Y;
  
    if (IS_HIDPI) {
      sourceX *= 2;
      sourceY *= 2;
    }
  
    this.spritePos = {x: sourceX, y: sourceY};
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    this.sourceDimensions = {};
    this.dimensions = lineConfig;
  
    this.sourceXPos = [this.spritePos.x, this.spritePos.x +
        this.dimensions.WIDTH];
    this.xPos = [];
    this.yPos = 0;
    this.bumpThreshold = 0.5;
  
    this.setSourceDimensions(lineConfig);
    this.draw();
  }
  
  
  /**
   * Horizon line dimensions.
   * @enum {number}
   */
  HorizonLine.dimensions = {
    WIDTH: 600,
    HEIGHT: 12,
    YPOS: 127,
  };
  
  
  HorizonLine.prototype = {
    /**
     * Set the source dimensions of the horizon line.
     */
    setSourceDimensions(newDimensions) {
      for (const dimension in newDimensions) {
        if (dimension !== 'SOURCE_X' && dimension !== 'SOURCE_Y') {
          if (IS_HIDPI) {
            if (dimension !== 'YPOS') {
              this.sourceDimensions[dimension] = newDimensions[dimension] * 2;
            }
          } else {
            this.sourceDimensions[dimension] = newDimensions[dimension];
          }
          this.dimensions[dimension] = newDimensions[dimension];
        }
      }
  
      this.xPos = [0, newDimensions.WIDTH];
      this.yPos = newDimensions.YPOS;
    },
  
    /**
     * Return the crop x position of a type.
     */
    getRandomType() {
      return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;
    },
  
    /**
     * Draw the horizon line.
     */
    draw() {
      this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],
          this.spritePos.y,
          this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
          this.xPos[0], this.yPos,
          this.dimensions.WIDTH, this.dimensions.HEIGHT);
  
      this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],
          this.spritePos.y,
          this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
          this.xPos[1], this.yPos,
          this.dimensions.WIDTH, this.dimensions.HEIGHT);
    },
  
    /**
     * Update the x position of an indivdual piece of the line.
     * @param {number} pos Line position.
     * @param {number} increment
     */
    updateXPos(pos, increment) {
      const line1 = pos;
      const line2 = pos === 0 ? 1 : 0;
  
      this.xPos[line1] -= increment;
      this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;
  
      if (this.xPos[line1] <= -this.dimensions.WIDTH) {
        this.xPos[line1] += this.dimensions.WIDTH * 2;
        this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;
        this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;
      }
    },
  
    /**
     * Update the horizon line.
     * @param {number} deltaTime
     * @param {number} speed
     */
    update(deltaTime, speed) {
      const increment = Math.floor(speed * (FPS / 1000) * deltaTime);
  
      if (this.xPos[0] <= 0) {
        this.updateXPos(0, increment);
      } else {
        this.updateXPos(1, increment);
      }
      this.draw();
    },
  
    /**
     * Reset horizon to the starting position.
     */
    reset() {
      this.xPos[0] = 0;
      this.xPos[1] = this.dimensions.WIDTH;
    },
  };
  
  
  //******************************************************************************
  
  /**
   * Horizon background class.
   * @param {HTMLCanvasElement} canvas
   * @param {Object} spritePos Sprite positioning.
   * @param {Object} dimensions Canvas dimensions.
   * @param {number} gapCoefficient
   * @constructor
   */
  function Horizon(canvas, spritePos, dimensions, gapCoefficient) {
    this.canvas = canvas;
    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
    this.config = Horizon.config;
    this.dimensions = dimensions;
    this.gapCoefficient = gapCoefficient;
    this.obstacles = [];
    this.obstacleHistory = [];
    this.horizonOffsets = [0, 0];
    this.cloudFrequency = this.config.CLOUD_FREQUENCY;
    this.spritePos = spritePos;
    this.nightMode = null;
    this.altGameModeActive = false;
  
    // Cloud
    this.clouds = [];
    this.cloudSpeed = this.config.BG_CLOUD_SPEED;
  
    // Background elements
    this.backgroundEls = [];
    this.lastEl = null;
    this.backgroundSpeed = this.config.BG_CLOUD_SPEED;
  
    // Horizon
    this.horizonLine = null;
    this.horizonLines = [];
    this.init();
  }
  
  
  /**
   * Horizon config.
   * @enum {number}
   */
  Horizon.config = {
    BG_CLOUD_SPEED: 0.2,
    BUMPY_THRESHOLD: .3,
    CLOUD_FREQUENCY: .5,
    HORIZON_HEIGHT: 16,
    MAX_CLOUDS: 6,
  };
  
  
  Horizon.prototype = {
    /**
     * Initialise the horizon. Just add the line and a cloud. No obstacles.
     */
    init() {
      Obstacle.types = Runner.spriteDefinitionByType.original.OBSTACLES;
      this.addCloud();
      // Multiple Horizon lines
      for (let i = 0; i < Runner.spriteDefinition.LINES.length; i++) {
        this.horizonLines.push(
            new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]));
      }
  
      this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,
          this.dimensions.WIDTH);
    },
  
    /**
     * Update obstacle definitions based on the speed of the game.
     */
    adjustObstacleSpeed: function() {
      for (let i = 0; i < Obstacle.types.length; i++) {
        if (Runner.slowDown) {
          Obstacle.types[i].multipleSpeed = Obstacle.types[i].multipleSpeed / 2;
          Obstacle.types[i].minGap *= 1.5;
          Obstacle.types[i].minSpeed = Obstacle.types[i].minSpeed / 2;
  
          // Convert variable y position obstacles to fixed.
          if (typeof (Obstacle.types[i].yPos) == 'object') {
            Obstacle.types[i].yPos = Obstacle.types[i].yPos[0];
            Obstacle.types[i].yPosMobile = Obstacle.types[i].yPos[0];
          }
        }
      }
    },
  
    /**
     * Update sprites to correspond to change in sprite sheet.
     * @param {number} spritePos
     */
    enableAltGameMode: function(spritePos) {
      // Clear existing horizon objects.
      this.clouds = [];
      this.backgroundEls = [];
  
      this.altGameModeActive = true;
      this.spritePos = spritePos;
  
      Obstacle.types = Runner.spriteDefinition.OBSTACLES;
      this.adjustObstacleSpeed();
  
      Obstacle.MAX_GAP_COEFFICIENT = Runner.spriteDefinition.MAX_GAP_COEFFICIENT;
      Obstacle.MAX_OBSTACLE_LENGTH = Runner.spriteDefinition.MAX_OBSTACLE_LENGTH;
  
      BackgroundEl.config = Runner.spriteDefinition.BACKGROUND_EL_CONFIG;
  
      this.horizonLines = [];
      for (let i = 0; i < Runner.spriteDefinition.LINES.length; i++) {
        this.horizonLines.push(
            new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]));
      }
      this.reset();
    },
  
    /**
     * @param {number} deltaTime
     * @param {number} currentSpeed
     * @param {boolean} updateObstacles Used as an override to prevent
     *     the obstacles from being updated / added. This happens in the
     *     ease in section.
     * @param {boolean} showNightMode Night mode activated.
     */
    update(deltaTime, currentSpeed, updateObstacles, showNightMode) {
      this.runningTime += deltaTime;
  
      if (this.altGameModeActive) {
        this.updateBackgroundEls(deltaTime, currentSpeed);
      }
  
      for (let i = 0; i < this.horizonLines.length; i++) {
        this.horizonLines[i].update(deltaTime, currentSpeed);
      }
  
      if (!this.altGameModeActive || Runner.spriteDefinition.HAS_CLOUDS) {
        this.nightMode.update(showNightMode);
        this.updateClouds(deltaTime, currentSpeed);
      }
  
      if (updateObstacles) {
        this.updateObstacles(deltaTime, currentSpeed);
      }
    },
  
    /**
     * Update background element positions. Also handles creating new elements.
     * @param {number} elSpeed
     * @param {Array<Object>} bgElArray
     * @param {number} maxBgEl
     * @param {Function} bgElAddFunction
     * @param {number} frequency
     */
    updateBackgroundEl(elSpeed, bgElArray, maxBgEl, bgElAddFunction, frequency) {
      const numElements = bgElArray.length;
  
      if (numElements) {
        for (let i = numElements - 1; i >= 0; i--) {
          bgElArray[i].update(elSpeed);
        }
  
        const lastEl = bgElArray[numElements - 1];
  
        // Check for adding a new element.
        if (numElements < maxBgEl &&
            (this.dimensions.WIDTH - lastEl.xPos) > lastEl.gap &&
            frequency > Math.random()) {
          bgElAddFunction();
        }
      } else {
        bgElAddFunction();
      }
    },
  
    /**
     * Update the cloud positions.
     * @param {number} deltaTime
     * @param {number} speed
     */
    updateClouds(deltaTime, speed) {
      const elSpeed = this.cloudSpeed / 1000 * deltaTime * speed;
      this.updateBackgroundEl(
          elSpeed, this.clouds, this.config.MAX_CLOUDS, this.addCloud.bind(this),
          this.cloudFrequency);
  
      // Remove expired elements.
      this.clouds = this.clouds.filter((obj) => !obj.remove);
    },
  
    /**
     * Update the background element positions.
     * @param {number} deltaTime
     * @param {number} speed
     */
    updateBackgroundEls(deltaTime, speed) {
      this.updateBackgroundEl(
          deltaTime, this.backgroundEls, BackgroundEl.config.MAX_BG_ELS,
          this.addBackgroundEl.bind(this), this.cloudFrequency);
  
      // Remove expired elements.
      this.backgroundEls = this.backgroundEls.filter((obj) => !obj.remove);
    },
  
    /**
     * Update the obstacle positions.
     * @param {number} deltaTime
     * @param {number} currentSpeed
     */
    updateObstacles(deltaTime, currentSpeed) {
      const updatedObstacles = this.obstacles.slice(0);
  
      for (let i = 0; i < this.obstacles.length; i++) {
        const obstacle = this.obstacles[i];
        obstacle.update(deltaTime, currentSpeed);
  
        // Clean up existing obstacles.
        if (obstacle.remove) {
          updatedObstacles.shift();
        }
      }
      this.obstacles = updatedObstacles;
  
      if (this.obstacles.length > 0) {
        const lastObstacle = this.obstacles[this.obstacles.length - 1];
  
        if (lastObstacle && !lastObstacle.followingObstacleCreated &&
            lastObstacle.isVisible() &&
            (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <
            this.dimensions.WIDTH) {
          this.addNewObstacle(currentSpeed);
          lastObstacle.followingObstacleCreated = true;
        }
      } else {
        // Create new obstacles.
        this.addNewObstacle(currentSpeed);
      }
    },
  
    removeFirstObstacle() {
      this.obstacles.shift();
    },
  
    /**
     * Add a new obstacle.
     * @param {number} currentSpeed
     */
    addNewObstacle(currentSpeed) {
      const obstacleCount =
          Obstacle.types[Obstacle.types.length - 1].type != 'COLLECTABLE' ||
              (Runner.isAltGameModeEnabled() && !this.altGameModeActive ||
               this.altGameModeActive) ?
          Obstacle.types.length - 1 :
          Obstacle.types.length - 2;
      const obstacleTypeIndex =
          obstacleCount > 0 ? getRandomNum(0, obstacleCount) : 0;
      const obstacleType = Obstacle.types[obstacleTypeIndex];
  
      // Check for multiples of the same type of obstacle.
      // Also check obstacle is available at current speed.
      if ((obstacleCount > 0 && this.duplicateObstacleCheck(obstacleType.type)) ||
          currentSpeed < obstacleType.minSpeed) {
        this.addNewObstacle(currentSpeed);
      } else {
        const obstacleSpritePos = this.spritePos[obstacleType.type];
  
        this.obstacles.push(new Obstacle(
            this.canvasCtx, obstacleType, obstacleSpritePos, this.dimensions,
            this.gapCoefficient, currentSpeed, obstacleType.width,
            this.altGameModeActive));
  
        this.obstacleHistory.unshift(obstacleType.type);
  
        if (this.obstacleHistory.length > 1) {
          this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);
        }
      }
    },
  
    /**
     * Returns whether the previous two obstacles are the same as the next one.
     * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.
     * @return {boolean}
     */
    duplicateObstacleCheck(nextObstacleType) {
      let duplicateCount = 0;
  
      for (let i = 0; i < this.obstacleHistory.length; i++) {
        duplicateCount =
            this.obstacleHistory[i] === nextObstacleType ? duplicateCount + 1 : 0;
      }
      return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;
    },
  
    /**
     * Reset the horizon layer.
     * Remove existing obstacles and reposition the horizon line.
     */
    reset() {
      this.obstacles = [];
      for (let l = 0; l < this.horizonLines.length; l++) {
        this.horizonLines[l].reset();
      }
  
      this.nightMode.reset();
    },
  
    /**
     * Update the canvas width and scaling.
     * @param {number} width Canvas width.
     * @param {number} height Canvas height.
     */
    resize(width, height) {
      this.canvas.width = width;
      this.canvas.height = height;
    },
  
    /**
     * Add a new cloud to the horizon.
     */
    addCloud() {
      this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,
          this.dimensions.WIDTH));
    },
  
    /**
     * Add a random background element to the horizon.
     */
    addBackgroundEl() {
      const backgroundElTypes =
          Object.keys(Runner.spriteDefinition.BACKGROUND_EL);
  
      if (backgroundElTypes.length > 0) {
        let index = getRandomNum(0, backgroundElTypes.length - 1);
        let type = backgroundElTypes[index];
  
        // Add variation if available.
        while (type == this.lastEl && backgroundElTypes.length > 1) {
          index = getRandomNum(0, backgroundElTypes.length - 1);
          type = backgroundElTypes[index];
        }
  
        this.lastEl = type;
        this.backgroundEls.push(new BackgroundEl(
            this.canvas, this.spritePos.BACKGROUND_EL, this.dimensions.WIDTH,
            type));
      }
    },
  };
  </script>
    <script>// Copyright 2021 The Chromium Authors
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.
  
  /* @const
   * Add matching sprite definition and config to Runner.spriteDefinitionByType.
   */
  const GAME_TYPE = [];
  
  /**
   * Obstacle definitions.
   * minGap: minimum pixel space between obstacles.
   * multipleSpeed: Speed at which multiples are allowed.
   * speedOffset: speed faster / slower than the horizon.
   * minSpeed: Minimum speed which the obstacle can make an appearance.
   *
   * @typedef {{
   *   type: string,
   *   width: number,
   *   height: number,
   *   yPos: number,
   *   multipleSpeed: number,
   *   minGap: number,
   *   minSpeed: number,
   *   collisionBoxes: Array<CollisionBox>,
   * }}
   */
  let ObstacleType;
  
  /**
   * T-Rex runner sprite definitions.
   */
  Runner.spriteDefinitionByType = {
    original: {
      LDPI: {
        BACKGROUND_EL: {x: 86, y: 2},
        CACTUS_LARGE: {x: 332, y: 2},
        CACTUS_SMALL: {x: 228, y: 2},
        OBSTACLE_2: {x: 332, y: 2},
        OBSTACLE: {x: 228, y: 2},
        CLOUD: {x: 86, y: 2},
        HORIZON: {x: 2, y: 54},
        MOON: {x: 484, y: 2},
        PTERODACTYL: {x: 134, y: 2},
        RESTART: {x: 2, y: 68},
        TEXT_SPRITE: {x: 655, y: 2},
        TREX: {x: 848, y: 2},
        STAR: {x: 645, y: 2},
        COLLECTABLE: {x: 2, y: 2},
        ALT_GAME_END: {x: 121, y: 2},
      },
      HDPI: {
        BACKGROUND_EL: {x: 166, y: 2},
        CACTUS_LARGE: {x: 652, y: 2},
        CACTUS_SMALL: {x: 446, y: 2},
        OBSTACLE_2: {x: 652, y: 2},
        OBSTACLE: {x: 446, y: 2},
        CLOUD: {x: 166, y: 2},
        HORIZON: {x: 2, y: 104},
        MOON: {x: 954, y: 2},
        PTERODACTYL: {x: 260, y: 2},
        RESTART: {x: 2, y: 130},
        TEXT_SPRITE: {x: 1294, y: 2},
        TREX: {x: 1678, y: 2},
        STAR: {x: 1276, y: 2},
        COLLECTABLE: {x: 4, y: 4},
        ALT_GAME_END: {x: 242, y: 4},
      },
      MAX_GAP_COEFFICIENT: 1.5,
      MAX_OBSTACLE_LENGTH: 3,
      HAS_CLOUDS: 1,
      BOTTOM_PAD: 10,
      TREX: {
        WAITING_1: {x: 44, w: 44, h: 47, xOffset: 0},
        WAITING_2: {x: 0, w: 44, h: 47, xOffset: 0},
        RUNNING_1: {x: 88, w: 44, h: 47, xOffset: 0},
        RUNNING_2: {x: 132, w: 44, h: 47, xOffset: 0},
        JUMPING: {x: 0, w: 44, h: 47, xOffset: 0},
        CRASHED: {x: 220, w: 44, h: 47, xOffset: 0},
        COLLISION_BOXES: [
          new CollisionBox(22, 0, 17, 16),
          new CollisionBox(1, 18, 30, 9),
          new CollisionBox(10, 35, 14, 8),
          new CollisionBox(1, 24, 29, 5),
          new CollisionBox(5, 30, 21, 4),
          new CollisionBox(9, 34, 15, 4),
        ],
      },
      /** @type {Array<ObstacleType>} */
      OBSTACLES: [
        {
          type: 'CACTUS_SMALL',
          width: 17,
          height: 35,
          yPos: 105,
          multipleSpeed: 4,
          minGap: 120,
          minSpeed: 0,
          collisionBoxes: [
            new CollisionBox(0, 7, 5, 27),
            new CollisionBox(4, 0, 6, 34),
            new CollisionBox(10, 4, 7, 14),
          ],
        },
        {
          type: 'CACTUS_LARGE',
          width: 25,
          height: 50,
          yPos: 90,
          multipleSpeed: 7,
          minGap: 120,
          minSpeed: 0,
          collisionBoxes: [
            new CollisionBox(0, 12, 7, 38),
            new CollisionBox(8, 0, 7, 49),
            new CollisionBox(13, 10, 10, 38),
          ],
        },
        {
          type: 'PTERODACTYL',
          width: 46,
          height: 40,
          yPos: [100, 75, 50],    // Variable height.
          yPosMobile: [100, 50],  // Variable height mobile.
          multipleSpeed: 999,
          minSpeed: 8.5,
          minGap: 150,
          collisionBoxes: [
            new CollisionBox(15, 15, 16, 5),
            new CollisionBox(18, 21, 24, 6),
            new CollisionBox(2, 14, 4, 3),
            new CollisionBox(6, 10, 4, 7),
            new CollisionBox(10, 8, 6, 9),
          ],
          numFrames: 2,
          frameRate: 1000 / 6,
          speedOffset: .8,
        },
      ],
      BACKGROUND_EL: {
        'CLOUD': {
          HEIGHT: 14,
          MAX_CLOUD_GAP: 400,
          MAX_SKY_LEVEL: 30,
          MIN_CLOUD_GAP: 100,
          MIN_SKY_LEVEL: 71,
          OFFSET: 4,
          WIDTH: 46,
          X_POS: 1,
          Y_POS: 120,
        },
      },
      BACKGROUND_EL_CONFIG: {
        MAX_BG_ELS: 1,
        MAX_GAP: 400,
        MIN_GAP: 100,
        POS: 0,
        SPEED: 0.5,
        Y_POS: 125,
      },
      LINES: [
        {SOURCE_X: 2, SOURCE_Y: 52, WIDTH: 600, HEIGHT: 12, YPOS: 127},
      ],
    },
  };
  </script>
    
  </head>
  <body id="t" class="neterror" style="font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 75%" jstcache="0">
    <div id="main-frame-error" class="interstitial-wrapper" jstcache="0">
      <div id="main-content" jstcache="0">
        <div class="icon icon-offline" jstcache="0" style="visibility: hidden;"></div>
        <div id="main-message" jstcache="0">
          <h1 jstcache="0">
            <span jsselect="heading" jsvalues=".innerHTML:msg" jstcache="9">Press space to play</span>
            <a id="error-information-button" class="hidden" onclick="toggleErrorInformationPopup();" jstcache="0"></a>
          </h1>
          <p jsselect="summary" jsvalues=".innerHTML:msg" jstcache="1" style="display: none;"></p>
          <!--The suggestion list and error code are normally presented inline,
            in which case error-information-popup-* divs have no effect. When
            error-information-popup-container has the use-popup-container class, this
            information is provided in a popup instead.-->
          <div id="error-information-popup-container" jstcache="0">
            <div id="error-information-popup" jstcache="0">
              <div id="error-information-popup-box" jstcache="0">
                <div id="error-information-popup-content" jstcache="0">
                  <div id="suggestions-list" style="display:none" jsdisplay="(suggestionsSummaryList &amp;&amp; suggestionsSummaryList.length)" jstcache="16">
                    <p jsvalues=".innerHTML:suggestionsSummaryListHeader" jstcache="18"></p>
                    <ul jsvalues=".className:suggestionsSummaryList.length == 1 ? 'single-suggestion' : ''" jstcache="19">
                      <li jsselect="suggestionsSummaryList" jsvalues=".innerHTML:summary" jstcache="21"></li>
                    </ul>
                  </div>
                  <div class="error-code" jscontent="errorCode" jstcache="17"></div>
                  <p id="error-information-popup-close" jstcache="0">
                    <a class="link-button" jscontent="closeDescriptionPopup" onclick="toggleErrorInformationPopup();" jstcache="20">null</a>
                  </p>
                </div>
              </div>
            </div>
          </div>
          <div id="download-links-wrapper" class="hidden" jstcache="0">
            <div id="download-link-wrapper" jstcache="0">
              <a id="download-link" class="link-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="6" style="display: none;">
              </a>
            </div>
            <div id="download-link-clicked-wrapper" class="hidden" jstcache="0">
              <div id="download-link-clicked" class="link-button" jsselect="downloadButton" jscontent="disabledMsg" jstcache="11" style="display: none;">
              </div>
            </div>
          </div>
          <div id="save-page-for-later-button" class="hidden" jstcache="0">
            <a class="link-button" onclick="savePageLaterClick()" jsselect="savePageLater" jscontent="savePageMsg" jstcache="10" style="display: none;">
            </a>
          </div>
          <div id="cancel-save-page-button" class="hidden" onclick="cancelSavePageClick()" jsselect="savePageLater" jsvalues=".innerHTML:cancelMsg" jstcache="4" style="display: none;">
          </div>
          <div id="offline-content-list" class="list-hidden" hidden="" jstcache="0">
            <div id="offline-content-list-visibility-card" onclick="toggleOfflineContentListVisibility(true)" jstcache="0">
              <div id="offline-content-list-title" jsselect="offlineContentList" jscontent="title" jstcache="12" style="display: none;">
              </div>
              <div jstcache="0">
                <div id="offline-content-list-show-text" jsselect="offlineContentList" jscontent="showText" jstcache="14" style="display: none;">
                </div>
                <div id="offline-content-list-hide-text" jsselect="offlineContentList" jscontent="hideText" jstcache="15" style="display: none;">
                </div>
              </div>
            </div>
            <div id="offline-content-suggestions" jstcache="0"></div>
            <div id="offline-content-list-action" jstcache="0">
              <a class="link-button" onclick="launchDownloadsPage()" jsselect="offlineContentList" jscontent="actionText" jstcache="13" style="display: none;">
              </a>
            </div>
          </div>
        </div>
      </div>
      <div id="buttons" class="nav-wrapper suggested-left" jstcache="0">
        <div id="control-buttons" hidden="" jstcache="0">
          <button id="reload-button" class="blue-button text-button" onclick="reloadButtonClick(this.url);" jsselect="reloadButton" jsvalues=".url:reloadUrl" jscontent="msg" jstcache="5" style="display: none;"></button>
          <button id="download-button" class="blue-button text-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="6" style="display: none;">
          </button>
        </div>
        <button id="details-button" class="secondary-button text-button small-link singular" onclick="detailsButtonClick(); toggleHelpBox()" jscontent="details" jsdisplay="(suggestionsDetails &amp;&amp; suggestionsDetails.length > 0) || diagnose" jsvalues=".detailsText:details; .hideDetailsText:hideDetails;" jstcache="2" style="display: none;"></button>
      </div>
      <div id="details" class="hidden" jstcache="0">
        <div class="suggestions" jsselect="suggestionsDetails" jstcache="3" style="display: none;">
          <div class="suggestion-header" jsvalues=".innerHTML:header" jstcache="7"></div>
          <div class="suggestion-body" jsvalues=".innerHTML:body" jstcache="8"></div>
        </div>
      </div>
    <div role="application" tabindex="0" title="Dino game, play" class="runner-container"><canvas class="runner-canvas" width="600" height="150" style="width: 600px; height: 150px;"></canvas><span class="offline-runner-live-region" aria-live="assertive">Dino game. A pixelated dinosaur dodges cacti and pterodactyls as it runs across a desolate landscape. When you hear an audio cue, press space to jump over obstacles.</span></div><label class="slow-speed-option hidden">Start slower<input type="checkbox" title="Start slower" tabindex="0" checked="checked"><span class="slow-speed-toggle"></span></label></div>
    <div id="sub-frame-error" jstcache="0">
      <!-- Show details when hovering over the icon, in case the details are
           hidden because they're too large. -->
      <div class="icon" jstcache="0"></div>
      <div id="sub-frame-error-details" jsselect="summary" jsvalues=".innerHTML:msg" jstcache="1" style="display: none;"></div>
    </div>
  
    <div id="offline-resources" jstcache="0"> <!-- my-res -->
      <img id="offline-resources-1x" src="1x.png" jstcache="0">
      <img id="offline-resources-2x" src="2x.png" jstcache="0">
      <template id="audio-resources" jstcache="0">
        <audio id="offline-sound-press" src="data:audio/mpeg;base64,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"></audio>
        <audio id="offline-sound-hit" src="data:audio/mpeg;base64,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"></audio>
        <audio id="offline-sound-reached" src="data:audio/mpeg;base64,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qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5Bkng/0BGmyKCAxgjmABrEAIwCAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="></audio>
      </template>
    </div>
  
  
  <script jstcache="0">(function(){function l(a,b,c){return Function.prototype.call.apply(Array.prototype.slice,arguments)}function m(a,b,c){var e=l(arguments,2);return function(){return b.apply(a,e)}}function n(a,b){var c=new p(b);for(c.h=[a];c.h.length;){var e=c,d=c.h.shift();e.i(d);for(d=d.firstChild;d;d=d.nextSibling)1==d.nodeType&&e.h.push(d)}}function p(a){this.i=a}function q(a){a.style.display=""}function r(a){a.style.display="none"};var t=/\s*;\s*/;function u(a,b){this.l.apply(this,arguments)}u.prototype.l=function(a,b){this.a||(this.a={});if(b){var c=this.a,e=b.a;for(d in e)c[d]=e[d]}else{var d=this.a;e=v;for(c in e)d[c]=e[c]}this.a.$this=a;this.a.$context=this;this.f="undefined"!=typeof a&&null!=a?a:"";b||(this.a.$top=this.f)};var v={$default:null},w=[];function x(a){for(var b in a.a)delete a.a[b];a.f=null;w.push(a)}function y(a,b,c){try{return b.call(c,a.a,a.f)}catch(e){return v.$default}}
  u.prototype.clone=function(a,b,c){if(0<w.length){var e=w.pop();u.call(e,a,this);a=e}else a=new u(a,this);a.a.$index=b;a.a.$count=c;return a};var z;window.trustedTypes&&(z=trustedTypes.createPolicy("jstemplate",{createScript:function(a){return a}}));var A={};function B(a){if(!A[a])try{var b="(function(a_, b_) { with (a_) with (b_) return "+a+" })",c=window.trustedTypes?z.createScript(b):b;A[a]=window.eval(c)}catch(e){}return A[a]}
  function E(a){var b=[];a=a.split(t);for(var c=0,e=a.length;c<e;++c){var d=a[c].indexOf(":");if(!(0>d)){var g=a[c].substr(0,d).replace(/^\s+/,"").replace(/\s+$/,"");d=B(a[c].substr(d+1));b.push(g,d)}}return b};function F(){}var G=0,H={0:{}},I={},J={},K=[];function L(a){a.__jstcache||n(a,function(b){M(b)})}var N=[["jsselect",B],["jsdisplay",B],["jsvalues",E],["jsvars",E],["jseval",function(a){var b=[];a=a.split(t);for(var c=0,e=a.length;c<e;++c)if(a[c]){var d=B(a[c]);b.push(d)}return b}],["transclude",function(a){return a}],["jscontent",B],["jsskip",B]];
  function M(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(null!=b)return a.__jstcache=H[b];b=K.length=0;for(var c=N.length;b<c;++b){var e=N[b][0],d=a.getAttribute(e);J[e]=d;null!=d&&K.push(e+"="+d)}if(0==K.length)return a.setAttribute("jstcache","0"),a.__jstcache=H[0];var g=K.join("&");if(b=I[g])return a.setAttribute("jstcache",b),a.__jstcache=H[b];var h={};b=0;for(c=N.length;b<c;++b){d=N[b];e=d[0];var f=d[1];d=J[e];null!=d&&(h[e]=f(d))}b=""+ ++G;a.setAttribute("jstcache",
  b);H[b]=h;I[g]=b;return a.__jstcache=h}function P(a,b){a.j.push(b);a.o.push(0)}function Q(a){return a.c.length?a.c.pop():[]}
  F.prototype.g=function(a,b){var c=R(b),e=c.transclude;if(e)(c=S(e))?(b.parentNode.replaceChild(c,b),e=Q(this),e.push(this.g,a,c),P(this,e)):b.parentNode.removeChild(b);else if(c=c.jsselect){c=y(a,c,b);var d=b.getAttribute("jsinstance");var g=!1;d&&("*"==d.charAt(0)?(d=parseInt(d.substr(1),10),g=!0):d=parseInt(d,10));var h=null!=c&&"object"==typeof c&&"number"==typeof c.length;e=h?c.length:1;var f=h&&0==e;if(h)if(f)d?b.parentNode.removeChild(b):(b.setAttribute("jsinstance","*0"),r(b));else if(q(b),
  null===d||""===d||g&&d<e-1){g=Q(this);d=d||0;for(h=e-1;d<h;++d){var k=b.cloneNode(!0);b.parentNode.insertBefore(k,b);T(k,c,d);f=a.clone(c[d],d,e);g.push(this.b,f,k,x,f,null)}T(b,c,d);f=a.clone(c[d],d,e);g.push(this.b,f,b,x,f,null);P(this,g)}else d<e?(g=c[d],T(b,c,d),f=a.clone(g,d,e),g=Q(this),g.push(this.b,f,b,x,f,null),P(this,g)):b.parentNode.removeChild(b);else null==c?r(b):(q(b),f=a.clone(c,0,1),g=Q(this),g.push(this.b,f,b,x,f,null),P(this,g))}else this.b(a,b)};
  F.prototype.b=function(a,b){var c=R(b),e=c.jsdisplay;if(e){if(!y(a,e,b)){r(b);return}q(b)}if(e=c.jsvars)for(var d=0,g=e.length;d<g;d+=2){var h=e[d],f=y(a,e[d+1],b);a.a[h]=f}if(e=c.jsvalues)for(d=0,g=e.length;d<g;d+=2)if(f=e[d],h=y(a,e[d+1],b),"$"==f.charAt(0))a.a[f]=h;else if("."==f.charAt(0)){f=f.substr(1).split(".");for(var k=b,O=f.length,C=0,U=O-1;C<U;++C){var D=f[C];k[D]||(k[D]={});k=k[D]}k[f[O-1]]=h}else f&&("boolean"==typeof h?h?b.setAttribute(f,f):b.removeAttribute(f):b.setAttribute(f,""+h));
  if(e=c.jseval)for(d=0,g=e.length;d<g;++d)y(a,e[d],b);e=c.jsskip;if(!e||!y(a,e,b))if(c=c.jscontent){if(c=""+y(a,c,b),b.innerHTML!=c){for(;b.firstChild;)e=b.firstChild,e.parentNode.removeChild(e);b.appendChild(this.m.createTextNode(c))}}else{c=Q(this);for(e=b.firstChild;e;e=e.nextSibling)1==e.nodeType&&c.push(this.g,a,e);c.length&&P(this,c)}};function R(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");return b?a.__jstcache=H[b]:M(a)}
  function S(a,b){var c=document;if(b){var e=c.getElementById(a);if(!e){e=b();var d=c.getElementById("jsts");d||(d=c.createElement("div"),d.id="jsts",r(d),d.style.position="absolute",c.body.appendChild(d));var g=c.createElement("div");d.appendChild(g);g.innerHTML=e;e=c.getElementById(a)}c=e}else c=c.getElementById(a);return c?(L(c),c=c.cloneNode(!0),c.removeAttribute("id"),c):null}function T(a,b,c){c==b.length-1?a.setAttribute("jsinstance","*"+c):a.setAttribute("jsinstance",""+c)};window.jstGetTemplate=S;window.JsEvalContext=u;window.jstProcess=function(a,b){var c=new F;L(b);c.m=b?9==b.nodeType?b:b.ownerDocument||document:document;var e=m(c,c.g,a,b),d=c.j=[],g=c.o=[];c.c=[];e();for(var h,f,k;d.length;)h=d[d.length-1],e=g[g.length-1],e>=h.length?(e=c,f=d.pop(),f.length=0,e.c.push(f),g.pop()):(f=h[e++],k=h[e++],h=h[e++],g[g.length-1]=e,f.call(c,k,h))};
  })()</script><script jstcache="0">// Copyright 2012 The Chromium Authors
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.
  
  /**
   * @fileoverview
   * NOTE: This file is deprecated, and provides only the minimal LoadTimeData
   * functions for places in the code still not using JS modules. Use
   * load_time_data.m.js in all new code.
   *
   * This file defines a singleton which provides access to all data
   * that is available as soon as the page's resources are loaded (before DOM
   * content has finished loading). This data includes both localized strings and
   * any data that is important to have ready from a very early stage (e.g. things
   * that must be displayed right away).
   *
   * Note that loadTimeData is not guaranteed to be consistent between page
   * refreshes (https://crbug.com/740629) and should not contain values that might
   * change if the page is re-opened later.
   */
  
  /** @type {!LoadTimeData} */
  // eslint-disable-next-line no-var
  var loadTimeData;
  
  class LoadTimeData {
    constructor() {
      /** @type {?Object} */
      this.data_ = null;
    }
  
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    }
  
    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists(id) {
      return id in this.data_;
    }
  
    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      const value = this.data_[id];
      expect(typeof value !== 'undefined', 'Could not find value for ' + id);
      return value;
    }
  
    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    }
  
    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF(id, var_args) {
      const value = this.getString(id);
      if (!value) {
        return '';
      }
  
      const args = Array.prototype.slice.call(arguments);
      args[0] = value;
      return this.substituteString.apply(this, args);
    }
  
    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument. Any standalone $ signs must be escaped as
     * $$.
     * @param {string} label The label to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    substituteString(label, var_args) {
      const varArgs = arguments;
      return label.replace(/\$(.|$|\n)/g, function(m) {
        expect(m.match(/\$[$1-9]/), 'Unescaped $ found in localized string.');
        return m === '$$' ? '$' : varArgs[m[1]];
      });
    }
  
    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    }
  
    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value === Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    }
  
    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues(replacements) {
      expect(
          typeof replacements === 'object',
          'Replacements must be a dictionary object.');
      for (const key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  }
  
  /**
   * Checks condition, throws error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      throw new Error(
          'Unexpected condition on ' + document.location.href + ': ' + message);
    }
  }
  
  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(
        typeof value === type, '[' + value + '] (' + id + ') is not a ' + type);
  }
  
  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData();
  
  // Expose |loadTimeData| directly on |window|, since within a JS module the
  // scope is local and not all files have been updated to import the exported
  // |loadTimeData| explicitly.
  window.loadTimeData = loadTimeData;
  
  console.warn('crbug/1173575, non-JS module files deprecated.');
  </script><script jstcache="0">const pageData = {"dinoGameA11yAriaLabel":"Dino game, play","dinoGameA11yDescription":"Dino game. A pixelated dinosaur dodges cacti and pterodactyls as it runs across a desolate landscape. When you hear an audio cue, press space to jump over obstacles.","dinoGameA11yGameOver":"Game over, your score is $1.","dinoGameA11yHighScore":"Your highest score is $1.","dinoGameA11yJump":"Jump!","dinoGameA11ySpeedToggle":"Start slower","dinoGameA11yStartGame":"Game started.","errorCode":"","fontfamily":"'Segoe UI', Tahoma, sans-serif","fontsize":"75%","heading":{"hostName":"dino","msg":"Press space to play"},"iconClass":"icon-offline","language":"en","textdirection":"ltr","title":"chrome://dino/"};loadTimeData.data = pageData;var tp = document.getElementById('t');jstProcess(new JsEvalContext(pageData), tp);</script></body></html>